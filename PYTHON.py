from __future__ import annotations
from pprint import pprint  # читабельный вывод вложенных объектов
from copy import deepcopy
from time import sleep

# фильтр для hh.ru
# Name:(python or django or drf or backend) and DESCRIPTION:(django or drf) NOT ментор NOT Senior not Преподаватель NOT TechLead NOT техлид

# интерактивное отображение работы пайтон
# https://pythontutor.com/

# интерактивное отображение алгоритмов
# https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

# рисовать диаграммы
# https://app.diagrams.net/

# Отменить действие в vscode:
# CTRL+Z
# Вернуть отменённое действие в vscode:
# CTRL+Y
# Импортировать модуль объекта на котором стоит курсор в vscode:
# CTRL+. затем ENTER

# Интерактивная консоль Python в vscode, типо IDLE
# CTRL+SHIFT+P
# Ввести: "repl"
# И выбрать: "Python: Запустить REPL"
# либо SHIFT+ENTER


# Типы данных

# Изменяемые (mutable)
# print(type(  {1, 1, "a"}     )) # -> set  Множество
# print(type(  {"a":1, 2:"b"}  )) # -> dict Словарь
# print(type(  [1, 1, "a"]     )) # -> list Список
# from array import array
# print(type(  array("l", [1, 1, 2])  ))      # -> array Массив
# print(type(  bytearray(3)  ), bytearray(3)) # -> Массив байт

# Неизменяемые (not mutable)
# print(type(  "abc"        )) # -> str      Строка
# print(type(  (1, 1, "a")  )) # -> tuple    Кортеж
# print(type(  None         )) # -> NoneType Отсутствие данных
# print(type(  True         )) # -> bool     Логическое значение
# print(type(  1            )) # -> int      Целое число
# print(type(  1.4          )) # -> float    Число с плавающей точкой
# from decimal import Decimal
# print(type(Decimal('1.4') )) # -> decimal  Точное число с плавающей точкой
# print(type(  1 + 1j       )) # -> complex  Комплексное число
# print(type(  frozenset([1, 1, "a"])  )) # -> frozenset неизменяемое множество
# print(type(  bytes(3)  ), bytes(3))     # -> Байт


# класс Decimal служит для более точной работы с дробными числами чем встроенный тип float
# print(Decimal('1.4') * Decimal('0.1'), 1.4 * 0.1)

# print(complex(2, 3j)) # создание комплексного числа

# Узнать айди объекта
# print(id('строка'))
# print(id([1, 2, 3]))

# узнать адресс в памяти в шестнадцатеричном формате
# print(hex(id('строка')))
# print(hex(id([1, 2, 3])))

# print(license())

# запустить Python код прямо в консоли:
# python -c 'for i in range(5):print(i)'

# memoryview позволяет коду Python получать доступ к внутренним данным объекта,
# который поддерживает буферный протокол, без необходимости копирования.
# Это позволяет программе использовать меньше памяти и увеличивает скорость выполнения.
# ba = bytearray('ABC', 'utf-8')
# mv = memoryview(ba)
# print('memoryview:', mv)
# print('байт под нулевым индексом:', mv[0])
# print('байт строка в unicode представлении:', bytes(mv[0:2]))
# print('список байт:', list(mv[0:2]))
# print(f'до изменения с помощью memoryview: {ba!r}')
# mv[1] = 90
# print(f'после изменения с помощью memoryview: {ba!r}')


# print("52 =", bytes(52)) # Преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# метод fromhex у класса bytes может преобразовывать шеснадцатиричную последовательность чисел в байт-строку
# b = bytes.fromhex('31 4B CE A9')
# print(b)
# b = b.decode('utf8')
# print(b) # один кило ОМ

# print("52 =", bin(52)) # преобразует десятичное число в двоичную (бинарную) строку с префиксом '0b'
# print("52 =", bin(52))[2:]

# print(bin(52), int(bin(52), 2)) # Возвращает двоичное представление целого числа.
# print(oct(52), int(oct(52), 8)) # Возвращает восьмеричное представление целого числа.
# print(hex(52), int(hex(52), 16)) # Возвращает шестнадцатеричное представление целого числа


# дизассемблировать(отобразить) байт-код скомпилированной функции на языке ассемблера.
# from dis import dis
# def func(a, b):
#     return a + b
# dis(func)


# Относительный импорт:
# from .filename import myfunc # импортировать функцию myfunc из файла filename который находится на одном уровне с файлом из котрого происходит импорт
# from ..filename import myfunc # импортировать функцию myfunc из файла filename который находится на уровень выше чем файл из котрого происходит импорт
# from ...filename import myfunc # импортировать функцию myfunc из файла filename который находится на два уровня выше чем файл из котрого происходит импорт
# и т.д.
# Абсолютный импорт:
# from foldername.filename import myfunc


# список изменяемый объект (id объекта всегда один и тот же)
# x = [1, 2, 3]
# print(id(x), x)
# x[2] = 6
# print(id(x), x)
# x.append(8)
# print(id(x), x)

# строка неизменяемый объект
# (но добавление нового элемента не меняет id в отличие от изменения существующего элемента)
# так работает в python <= 3.8, в python 3.11 например, id изменяется при любом раскладе
# y = '123'
# print(id(y), y)
# y = y[:2] + '6'
# print(id(y), y)
# y += '8'
# print(id(y), y)

# Области видимости (Пространства имен)
# built-in # встроенные функции в интерпретаторе, для их использования не надо импортировать модули, а так же операторы (зарезервированные слова).
# global   # объекты доступные в пространстве имён модуля.
# local    # объекты доступные внутри функции.
# nonlocal # делает доступной переменную в блоке внешней функции (обёртки).

# def a():
#     ''' документация функции "a" '''
# class b:
#     ''' документация класса "b" '''
#     def MY_METHOD_MY_METHOD_MY_METHOD_MY_METHOD_MY_METHOD():
#         pass
# print('Имя объекта:', a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print('Документация объекта:', a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # возвращает словарь с доступными объектами в пространстве имён текущего модуля

# import math
# pprint(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имён модуля)
# def func(): pass
# # получить список атрибутов объекта
# pprint(dir(func))
# pprint(func.__dir__())

# print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имён модуля

# pprint(__builtins__.__dict__) # посмотреть словарь со встроенными объектами
# print(str.__dict__)
# print(vars(str))

# print(callable(len), callable('строка')) # проверяем является ли объект вызываемым

# print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря
# print(vars()) # без аргумента работает как locals

# узнать инфу о функции
# def func(a: str, b: int) -> list:
#     c = 2; d = 'Hello, World!'
#     return c, d
# print(func.__code__.co_argcount)
# print(func.__code__.co_consts)
# print(func.__code__.co_varnames)

# Узнать родителей в иерархическом порядке у объекта
# class A: pass
# class B(A): pass
# print(B.mro())

# принадлежность объекта к конкретному классу можно проверить функцией isinstance
# 1арг. объект который мы хотим проверить, 2арг. класс (или кортеж классов) к которому они должны принадлежать, вернёт True/False
# print(isinstance('строка', int))
# print(isinstance('строка', str))
# # либо тоже самое с помощью класса type()
# print(type('строка') == int)
# print(type('строка') == str)

# принадлежность объекта к конкретному субклассу можно проверить функцией issubclass
# 1арг. тип к которому должен принадлежать объект который мы хотим проверить, 2арг. тип (или кортеж типов) проверяемых объектов, вернёт True/False
# print(issubclass(int, type(72)))
# print(issubclass(int, type("Hello World!")))
# print(issubclass(str, type("Hello World!")))

# class Obj: myattr = 7
# # получить атрибут у объекта
# print('getattr:', getattr(Obj, 'myattr')) # obj, name
# # установить атрибут для объекта
# setattr(Obj, 'myattr2', 'Hello World!') # obj, name, value
# # удалить атрибут у объекта
# delattr(Obj, 'myattr') # obj, name
# # проверить есть ли атрибут у объекта, возвращает True/False
# print('hasattr:', hasattr(Obj, 'myattr2')) # obj, name
# print('hasattr:', hasattr(Obj, 'myattr'))

# функция type определяет тип данных
# if type(True) == bool :
# 	print("bool")
# if type(1) == int :
# 	print("int")

# класс bool преобразует числовое значение в истину или ложь
# если число 0 значит ложь, если число больше или меньше 0 то истина
# print(bool(11))
# print(bool(-11))
# print(bool(0))
# так же работает и со строками, только в качестве лжи применяется пустая строка
# print(bool('a'))
# print(bool(''))
# так же и с коллекциями
# print(bool([1, 2]))
# print(bool([]))

# умножение разных типов данных
# print(1*5)
# print('1'*5) # строка
# print([[]]*5) # список
# print((1,)*5) # кортеж
# print(True*5, 1*5) # булевые
# print(False*5, 0*5)

# булевые значения можно суммировать если они суммируются в integer object
#         1     1      0      1     0
# array = [True, True, False, True, False]
# int_count = 0
# for bool_value in array:
#     int_count += bool_value
# print(int_count, sum(array))

# print(hash('string')) # хэш можно найти только у неизменяемых типов данных
# print(hash([1, 2, 3])) # TypeError: unhashable type: 'list'
# если в кортеже будет находиться изменяемый тип данных
# он перестаёт иметь хэш, функция выбросит исключение TypeError
# print(hash((1, 2, '3', '4')))
# print(hash((1, 2, [3, 4])))
# Если объекты равны то их хэш тоже равен
# Но равные хэши не гарантируют на 100% равенство объекта
# Если хэши не равны то объекты точно не равны
# print(hash((1, 2)), hash((1, 2)))
# print(hash('Hello World!'), hash('Hello World!'))

# код можно писать в одну строку с помощью точки с запятой ';'
# a = 1; b = 2; c = [1, 2]
# print(a, b, c)

# по умолчанию print разделяет аргументы одиночными пробелами
# но при помощи параметра sep можно указать другой разделитель
# print('a', 'b', 'c', sep='111')

# параметр end может склеивать принты вместе
# print('a', 'b', 'c', end=' ')
# print('d', 'e', 'f')

# читабельный вывод словарей с табуляцией
# import json
# print(json.dumps(словарь, indent=4, ensure_ascii=False))

# перевод числового значения int или float в строку с помощью метода str()
# a = 5
# b = 5.7
# c = 'Строка с числом ' + str(a) + str(b)
# print(c)

# функция input запрашивает данные для ввода и передаёт их в строке
# функция int переводит строковые значения(цифровые) в целые числа
# функция float переводит строковые значения(цифровые) в числа с плавающей точкой
# a = input("Введите число:\n")
# b = int(a) + 5
# b = float(a) + 5
# print(b)

# a = float(input("Введите число: "))
# b = float(input("Введите число: "))
# print("Результат:", a + b)
# print("Результат:" + str(a + b)) # объединение строки с числом

# # eval() может выполнить лишь выражение Python.
# print(eval("1024 + 1024"))
# print(eval("sum([8, 16, 32])"))
# print(eval("min([1, 2, 3])"))
# print(eval("[i for i in range(5)]"))
# x, y = 7, 7
# print(eval("x != y")) # в eval можно передавать глобальные переменные
# print(eval("x != y", {"x": 7})) # в eval можно указать только определенные переменные в формате словаря которые должны попасть в функцию.
# # compile() можно использовать для предоставления объектов кода для eval() вместо обычных строк.
# code = compile("5 + 4", "<string>", "eval")
# print(eval(code))
# # exec() может выполнить любой фрагмент кода Python.
# exec("if 1 > 0: print('да, 1 больше 0')")

# простейший калькулятор с использованием функции eval
# while True: print(eval(input()))

# while True:
#     text = input()
#     try:
#         result = eval(text)
#         print("\033[A                             \033[A")
#         print(text, '=', result)
#     except Exception as exc:
#         print(exc)


# print(1)
# print(2)
# print(3)
# for _ in range(3):
#     sleep(1)
#     print("\033[A                             \033[A") # удаляет одну строку в консоли

# Операторы условий
# if
# elif
# else
# :
# pass # оператор заглушка, допустим что бы не писать print() или кавычки документации ''' '''
# ... # так же работает как заглушка
# del <объект> # оператор удаления объекта
# del(<объект>) # тоже самое только с указанием объекта для удаления в круглых скобках

# Логические операторы (имеют приоритет выполнения)
# not # первый
# and # второй
# or  # третий

# continue # оператор для работы с циклами, пропускает итерацию и начинает следующую с самого начала
# break # оператор для работы с циклами, останавливает цикл и выходит из тела цикла
# else # оператор в том числе и для работы с циклами, сработает только в том случае
# если цикл завершиться сам по себе, то есть выполнит все итерации


# создаём генератор выдающий по байту за раз в правой части и итерируемся по нему в левой части
# print(chr(i) for i in range(1, 4))
# for char in (chr(i) for i in range(1, 4)):
#     print(char)


# добавить более одного элемента за итерацию используя collection comprehension
# можно с помощью вложенных циклов и тернарного оператора
# lst = [1, 0, 2, 3, 0, 4]
# res = [num_or_text for N in lst for num_or_text in ([N] if N else ['Hello', 'World'])]
# print(res)


# выражение присваивания/моржовый оператор
# присваиваем b значение a ** 2
# и проверяем если b > 0
# a = 4

# if (b := a ** 2) > 0:
#     print(f'Квадрат {a} это {b}')

# # без использования скобок в b присвоится True
# if b := a ** 2 > 0:
#     print(f'Квадрат {a} это {b}')

# name = 'Arseniy Astafev'
# x = False

# if (name := name.split()[-1]) and not x:
#     print(name)
# print(name)

# # без использования скобок в name присвоится True
# if name := name.split()[-1] and not x:
#     print(name)
# print(name)


# на самом деле оператор del удаляет не сам объект а ссылку на объект
# и в качестве побочного результата сборщик мусора должен удалить объект
# если на него более никто не ссылается
# from sys import getrefcount
# from weakref import finalize
# a = {1, 2}
# ender = finalize(a, lambda : print('Garbage Collector eat {1, 2} object'))
# print('refcount:', getrefcount(a), ' object alive?', ender.alive)
# b = a # теперь на объект {1, 2} ссылаются переменные "a" и "b"
# print('refcount:', getrefcount(a), ' object alive?', ender.alive)
# c = b # теперь на объект {1, 2} ссылаются переменные "a", "b", "c"
# print('refcount:', getrefcount(a), ' object alive?', ender.alive)
# del a # теперь на объект {1, 2} ссылаются переменные "b", "c"
# print('refcount:', getrefcount(c), ' object alive?', ender.alive)
# del b # теперь на объект {1, 2} ссылается только переменная "c"
# print('refcount:', getrefcount(c), ' object alive?', ender.alive)
# c = 'Hello World!' # теперь на объект {1, 2} более никто не ссылается и сборщик мусора может удалить объект
# print('             object alive?', ender.alive)


# конструкция math case позволяет проверять первый аргумент последовательности
# и записывать последующие в переменные
# message = ['BEEPER', 440, 3]
# message = ['LED', 77, '214', '251', '192']
# # message = ['NECK', 440]
# # message = ['UNKNOWN', 'abcdef']
# match message:
#     case ['BEEPER', frequency, times]:
#         print(1)
#     case ['NECK', angle]:
#         print(2)
#     case ['LED', ident, intensity]:
#         print(3)
#     # можно указывать охранное условие if на ряду с case
#     case ['LED', ident, red, green, blue] if int(green) < 255:
#         print(4)
#     case _:
#         print(5)

# phone = '162367721261'
# phone = '262367721261'
# phone = '362367721261'
# phone = '462367721261'
# match tuple(phone): # превращаем строку в коллекцию символов
#     case ['1', *rest]: # проверяем первый символ остальные помещаем в переменную rest
#         print(1)
#     case ['2', *rest]:
#         print(2)
#     case ['3' | '4', *rest]:
#         print(3, 4)

# location = ['Shanghai', 'CN', 24.9, (31.1, 121.3)]
# match location:
#     # для переменных можно указывать алиасы
#     case [name as title, _, _, (lat, lon) as coord]:
#         print(title, coord)


# i = 0
# print('>>> IN')
# while i < 10:
#     i += 1
#     if i > 3 and not i > 6: # если i больше 3 и i не меньше 6 тогда пропускаем итерацию
#         print('i =', i, 'continue')
#         continue
#     print('i =', i)
#     if i == 8:
#         print('i =', i, 'break')
#         break
# else:
#     print('сработал оператор else')
# print('>>> OUT')

# вместо двух указателей идущих на встречу друг другу можно использовать цикл
# N = 3
# for i in range(N):
#     print(i, N-i-1)

# Убираем повторяющиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
#     if not i in b:
#         b.append(i)
# print(a)
# print(b)

# сортировка строки по маленьким/большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
# for i in s:
#     if i >= 'a' and i <= 'z':
#         print(i, 'small')
#     elif 'A' <= i <= 'Z':
#         print(i, 'big')
#     else:
#         print(i, 'не буквенный символ')

# подсчёт количества повторяющихся букв в строке с помощью циклов
# s = 'abczjhdf HG jgkfYGg jhgkdf 543 *(^($&*#'
# letters = [0] * 26
# for i in s.lower():
#     if i >= 'a' and i <= 'z':
#         number = ord(i) - 97
#         letters[number] += 1
# for i in range(26):
#     if letters[i] > 0:
#         print(chr(i + 97), letters[i])

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона с помощью операторов сравнений
# number = 4
# if 3 <= number <= 6:
# # if number >= 3 and number <= 6: # аналогичная запись
#     print('число в диапазоне от 3 до 6')

# операторы сравнения можно записывать в цепочке
# a, b, c, d = 1, 1, 1, 1
# if a == b == c == d:
#     print('все числа равны')

# оператор 'in' если часть объекта равна возвращает логическое значение True иначе False
# link1 = 'https://'
# link2 = 'https://#'
# link3 = 'https://www.youtube.com'
# print(link1 in link3) # True
# print(link2 in link3) # False

# оператор 'is' если объекты ссылаются на одну и туже ячейку в памяти то возвращает логическое значение True иначе False
# x = 10
# y = 10
# print(x is y) # True

# для слишком больших чисел выделяется отдельная область в памяти
# x = 31**25
# y = 31**25
# print(x, y, x is y) # True
# x = 31**26
# y = 31**26
# print(x, y, x is y) # False

# x = 32**21
# y = 32**21
# print(x, y, x is y) # True
# x = 32**25
# y = 32**25
# print(x, y, x is y) # False

# x = 25**25
# y = 25**25
# print(x, y, x is y) # True
# x = 26**26
# y = 26**26
# print(x, y, x is y) # False


# для списков выделяется отдельная область в памяти
# x = [1, 2, 3]
# y = x
# z = [1, 2, 3]
# print(x is y) # True
# print(y is z) # False
# print(x is z) # False

# float('inf') считается самым большим числом в python, он действует как неограниченное верхнее значение для сравнения
# print(float('inf') > 99999**99999) # True
# float('-inf) считается самым малым числом в python.
# print(float('-inf') < -9999999999) # True
# from math import inf
# print(inf == float('inf'))

# создать и проверить объект на NaN
# from math import isnan
# nan = float('nan')
# print(isnan(nan)) # True
# print(isnan(1.7)) # False

# Математические операторы (имеют приоритет выполнения)
# a = 10 + 5
# a = 10 - 5
# a = 10 * 5
# a = 19 / 5 # обычное деление, ответ = 3.8
# a = 19 // 5 # деление с отбросом остатка после точки (в числе 19 число 5 помещается 3 раза)

# Остаток от деления 19 % 7 в число 19 число семь помещается 2 раза, остаток = 5

# Так же можно находить числа кратные числу, например найти числа кратные 4 в последовательности чисел
# for n in range(21):
#     if n % 4 == 0:
#         print(n)

# a = число % 2 # узнаём есть ли остаток после точки при делении
# возвращает 0 если остатка нет, 1 если остаток есть (можно вычислять четные или не четные числа)

# for n in range(1, 11):
#     if n % 2 == 0:
#         stri = 'Четное'
#     else:
#         stri = 'Не четное'
#     print(f'Число: {n} {stri}')

# a = 6 ** 3 # возведение в степень (аналог 6*6*6)
# унарный минус
# a = 10
# a = -a # из положительного в отрицательное значение
# a = -a # из отрицательного в положительное значение
# print(a)

# Операции с числами
# print(sum( [10, 7, 2, 15] )) # функция sum() складывает все числовые значения из списка
# print(abs(-13.2)) # функция abs() переводит число из отрицательного в положительное
# print(min(16,9,-3,42,25)) # возвращает минимальное число
# print(max(90,4,-2,54,63)) # возвращает максимальное число
# print(pow(16, 7), 16**7) # функция pow() возводит число в степень
# округление числа с плавающей точкой
# print(round(5.758, 1)) # округление от середины # так же может иметь 2 арг. который будет указывать с какой точки начинать округлять
# import math
# print(math.ceil(5.7)) # округление всегда в большую сторону
# print(math.floor(5.7)) # округление всегда в меньшую сторону
# print(math.trunc(54.748)) # обрезает знаки после точки оставляя только целое число # точно так же работает int(54.748)
# print("pi =", math.pi) # число пи

# print(
#     divmod(5, 5),
#     (5//5, 5%5),
#     (math.floor(5/5), 5%5),
# )
# lst = [1, 3, 5, 7, 9]
# print([divmod(x, 2) for x in lst])
# [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1)]

# для разделения математических операций по приоритету используются круглые скобки
# приоритет на примере
# # 7   5   6   4   3     2     1
# y = x + 7 > x + 2 * (x ** (3 ** x) )

# Арифметическая прогрессия
# a = int(input()) # 1  # 100
# b = int(input()) # 1  # 50
# c = int(input()) # 10 # 1
# x = a + b * (c - 1)
# print(x)

# Геометрическая прогрессия
# a = int(input()) # 1 # -2
# b = int(input()) # 2 # 10
# c = int(input()) # 5 # 3
# x = a * b ** (c - 1)
# print(x)

# разделение числа посимвольно с помощью математических операторов, замена срезам/индексации строк
# a = 1234
# n1 = a // 1000 # для первой цифры можно не использовать остаток от деления
# n2 = a // 100 % 10
# n3 = a // 10 % 10
# n4 = a // 1 % 10
# print(n1, n2, n3, n4, sep='   ')

# операции присваивания в пайтон
# a += b прибавляем a к b (аналог a = a + b)
# a -= b (аналог a = a - b)
# a *= b (аналог a = a * b)
# a /= b (аналог a = a / b)
# a //= b (аналог a = a // b)
# a %= b (аналог a = a % b)
# a &= b (аналог a = a & b)
# a |= b (аналог a = a | b)

# программа открывающая сайт https://www.youtube.com
# input не пропускает цикл пока пользователь не введёт какие либо данные
# import os
# while True :
# 	sayt = input("Введите адрес сайта:\n")
# 	if sayt == "завершить" :
# 		break
# 	if "https://" in sayt :
# 		os.system("start " + sayt)
# 		print("if")
# 	elif "www." in sayt :
# 		sayt = "https://" + sayt
# 		os.system("start " + sayt)
# 		print("elif")
# 	else :
# 		sayt = "https://www." + sayt
# 		os.system("start " + sayt)
# 		print("else")

# import time
# import os
# time.sleep(3)
# os.system("start https://www.youtube.com")
# time.sleep(3)
# os.system("start https://www.twitch.tv")
# time.sleep(3)
# os.startfile("C:\Program Files\CPUID\CPU-Z\cpuz.exe")

# полностью очистить терминал
# import os
# os.system('cls') # для windows
# os.system('clear') # для linux/mac

# модуль рандом
# import random
# print(random.randint(0, 0xFFFFFF))
# print(random.randint(0, 100)) # выбрать рандомный элемент из диапазона
# print(random.randrange(1, 100)) # выбрать рандомный элемент из range
# # выбрать рандомный элемент из коллекции
# print(random.choice(['Lorem', 'ipsum', 'dolor', 'sit', 'amet,', 'consectetur', 'adipiscing', 'elit']))
# lst = list(range(1, 10))
# print(lst)
# random.shuffle(lst) # перемешать элементы в коллекции
# print(lst)

# while оператор цикла исполняется (пока условие верно)
# цикл от 1 до 5
# можно подключить оператор else который сработает по завершению цикла
# a = 0
# while a < 5 :
# 	a += 1
# 	print(a)
# else :
# 	print("finish")

# while True :
# 	a = int(input())
# 	b = 1
# 	count = 0
# 	while count < a :
# 		count += 1
# 		b *= count
# 	else :
# 		print("result:", b)

# while True :
# 	a = ""
# 	while len(a) < 5 :
# 		b = input("Ввод данных: ")
# 		if b == "o" :
# 			continue # игнорируем символ
# 		if b == "t" :
# 			break # прерываем цикл
# 		a += b
# 	else :
# 		print("result:", a)
# 	print(">>> Сброс программы <<<")


# def _len(x):
#     print(_len.__name__, x)
#     return len(x)

# # в условии цикла while не стоит использовать вызываемые объекты т.к. они будут выполнены на каждой итерации
# L = [1, 2, 3]
# while _len(L) < 5:
#     pass


# цикл for

# basket = [1,2,3,4,5,6]
# # спискам в цикле можно применять метод среза тем самым укоротив цикл до 3 итераций
# for i in basket[:3]:
#     print(i)

# можно подключить оператор else который сработает по завершению цикла
# ищем конкретные символы
# a = "test text"
# count = 0
# for i in a :
# 	if i == "t" :
# 		print("найдено совпадение:", i)
# 		count += 1
# 	if i == "x" :
# 		break
# else :
# 	print("result:", i, "=", count)

# пропускаем символы
# a = "test text"
# count = 0
# for i in a :
# 	if i == "t" :
# 		continue
# 	print(i)
# else :
# 	print("result:", i, "=", count)

# подсчёт количества повторяющихся символов
# while True :
# 	a = "йцукенгшщзхъфывапролджэячсмитьбю0123456789"
# 	b = input("Введите строку:\n")
# 	for i in a :
# 		count = 0
# 		for index in b :
# 			if i == index :
# 				count += 1
# 		if count > 0 :
# 			# idk :D
# 			if count == 2 or count == 3 or count == 4 or count == 22 or count == 23 or count == 24 :
# 				name = "раза"
# 			else :
# 				name = "раз"
# 			print("буква", '"' + i + '"', "попалась", count, name)

# функция range принимает аргументы (start, end, step)
# for i in range(3, 16, 2) :
# 	print(i)

# for i in range(10, -1, -1): # обратная последовательность от 10 до 0
#     print(i)
# либо так
# for i in range(11)[::-1]:
#     print(i)

# for i in range(-10, 0): # отрицательная последовательность от -10 до -1
#     print(i)

# a = range(10001)
# b = list(range(10001))
# # к range можно применять срезы, обращаться по индексу.
# print(a[4], a[10:16], list(a[10:16]))
# # объект range не хранит всю последовательность в памяти как генератор.
# print('размер range:', a.__sizeof__())
# print('размер list:', b.__sizeof__())


# итерация элементов в итерируемом объекте с помощью функций iter, next
# r = range(4)
# # print(r, type(r)) # range(0, 4) <class 'range'>
# # r = [0, 1, 2, 3]
# # print(r, type(r)) # [0, 1, 2, 3] <class 'list'>

# it = iter(r)
# # it = r.__iter__() # тоже самое просто другой синтаксис
# # print(it, type(it)) # <range_iterator object at 0x0000027F539A9810> <class 'range_iterator'>

# n1 = next(it)
# n2 = next(it)
# n3 = next(it)
# n4 = it.__next__() # тоже самое просто другой синтаксис

# print(n1, n2, n3, n4)
# Если элементы закончатся и ещё раз вызвать next то сработает исключение StopIteration

# т.к. класс map возвращает итератор он может вернуть одно значение только один раз
# поэтому при поиске значения с помощью оператора in в итераторе,
# под капотом происходит последовательный перебор всех элементов итератора,
# поэтому найти значения которые находятся раньше элемента на котором был остановлен перебор уже не получиться.
# iterator = map(abs, [1, 2, 3, 4, 5])
# print(2 in iterator)  # True
# print(4 in iterator)  # True
# print(2 in iterator)  # False
# print(3 in iterator)  # False
# print(list(iterator)) # []


# a = [5, 6, 7]
# b = [100, 200, 300, 400]
# # объект итератор zip упаковывает в кортеж значения стоящие на одинаковых индексах в двух и более списках
# zp = zip(a, b)
# print('zip:', zp, list(zp))

# # тоже самое только с помощью цикла
# lst = []
# for i in range(min(len(a), len(b))):
#     lst.append((a[i], b[i]))
# print('lst:', lst)

#########################################################################################
# Список (list) упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#########################################################################################

# индексация с конца            -4              -3                -2               -1
# индексация с начала            0               1                 2                3
# xxxxxxxxxxxxxxxxxxxxx = ['Выпить кофе', 'Изучить Python', 'Захватить мир', 'Купить хлеба']

# узнать длинну списка можно с помощью функции len(имя списка)
# в питон есть обратная индексация с конца к началу с помощью знака - вместо нуля идёт -1 и т.д.
# a = [4, 2, 33, "строка", 5, ["a", "b", 16] ]
# print(a[0])
# без исключения обратится к последнему элементу списка (если он пустой):
# lst = []
# a = lst[-1:] or None
# print(a)
# можно обращатся к вложенным спискам внутри списка таким способом
# print(a[-1][1])
# можно перезаписывать определённую ячейку из списка
# a[0] = 7
# print(a[0])
# можно менять данные в списке или списках местами множественным присваиванием # https://younglinux.info/python/task/exchange
# a[0], a[2] = a[2], a[0]
# print(a[0], a[2])
# можно добавить данные в список
# a = a + [7]
# print(a)
# функция list() разбивает строку по 1 символу и превращает её в список
# a = list("5861cfg")
# print(a)

# сравнение списков (при этом происходит поочередное сравнение каждого элемента списка слева на право)
# print('[1] <= [1]', [1] <= [1])
# print('[2] <= [1]', [2] <= [1])
# print('[1, 1] <= [1, 1]', [1, 1] <= [1, 1])
# print('[1, 2] <= [1, 1]', [1, 2] <= [1, 1])

# с помощью fromkeys можно исключить дубликаты из последовательности,
# сохранив при этом порядок элементов в отличие от set()
# lst = ['spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs']
# tpl = ('spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs')
# print(list(dict.fromkeys(lst).keys()))
# print(list(dict.fromkeys(tpl).keys()))
# print(list(set(lst)))

# Пару вариантов получения одного из двух ключей в словаре если он существует иначе None
# key = ([k for k in kwargs if k in ("id__in", "pk__in")] or (None,))[0]
# key = ("id__in" if "id__in" in kwargs else None) or ("pk__in" if "pk__in" in kwargs else None)

########################################
# Методы для работы со списками (list) #
########################################

# x = [9, 8, 7, 6, 5]
# print(7 in x[1:3]) # с помощью среза проверяем есть ли данный элемент в списке в промежутке от 1 до 3 индекса
# print(len(x)) # узнать длинну списка
# x.append("kek") # добавляет элемент в конец списка
# x.insert(1, 7) # добавляет элемент перед указанным индексом
# print(x.count(7)) # узнаём сколько одинаковых элементов в списке по имени элемента
# print(x.index(7)) # узнаём индекс элемента в списке по имени элемента (2арг. с какого индекса начинать искать, 3арг. на каком закончить искать)
# x.sort() # сортирует список по возрастанию, если добавить арг. reverse=True список отсортируется по убыванию
# так же у способов sort и sorted имеется второй именованный арг. key=функция для изменения принципа сортировки
# примечание, sort и sorted сортирует как цифры так и каждый символ в строке включая буквы
# c = sorted(x, key=abs) # возвращает новый отсортированный список в формате списка в переменную (родительский не трогает)
# x.reverse() # инвертирует список и перезаписывает его в эту же ячейку памяти (способ без метода x[:] = x[::-1])
# print(reversed('98765')) # создаёт итератор с инвертированными элементами
# (аналогично x = list('98765') x.reverse() print(x))
# x.pop(0) # удаляет элемент по указанному индексу (если указать переменную то сохранит удалённый элемент в переменную)
# по умолчанию без аргумента pop() удаляет элемент в конце списка, является аналогом del список[-1]
# x.remove(7) # удаляет конкретный элемент в списке по имени элемента
# x.clear() # полностью очищает список
# x.extend(["asd", "gg", 123]) # распаковывает список в конце списка
# c = x.copy() # создаёт копию списка в переменную (аналоги c = x[:] или c = list(x))
# c = ["Hello"]+["Random"]+["Friend"] # списки можно складывать
# print(c)
# print(x)
# new_text = '___'.join(c) # переводим список обратно в строку в качестве пробелов можно указать любой символ
# print(new_text)

# a = list(range(10))
# b = []
# for i in a:
#     if i == 5 or i == 6:
#         continue
#     # b += [i]
#     b.append(i) # аналогично
# else:
#     print(b)

# в списках можно использовать синтаксис срезов так же как и в строках

# a = list(range(1, 21))
# b = []
# если нам нужно поверхностно скопировать список то используем метод copy()
# c = a.copy()
# либо можно поверхностно скопировать таким способом
# g = list(a)
# print(id(a), id(g))
# либо поверхностное копирование с помощью синтаксиса срезов [start:stop:step]
# c = a[::] # полный список
# c = a[0::2] # заменяем цикл одной строчкой
# c = a[1::2] # заменяем цикл одной строчкой
# c = a[:5]
# c[:2] = ['gg', 'wp'] # заменяем первые 2 элемента на элементы из нового списка
# c[:2] = [] # удаляем первые 2 элемента т.к. заменяем их пустотой, если написать c[:] можно очистить весь список
# так же можно заменять значение по конкретному индексу c[3] = 6
# print(c)

# del c[2] # удалить значение по индексу

# for i in a:
#     if i % 2 == 0:
#         a.remove(i) # из списка a удаляем числа кратные 2 то есть получаем нечетные
#         b.append(i) # в список b записываем только числа кратные 2 то есть четные
# else:
#     print("a:", a)
#     print("b:", b)
#     print("c:", c)

#######################################################################################################
# Кортеж (tuple) неизменяемая упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#######################################################################################################

# x = 1, # создание кортежа без помощи круглых скобок с одним значением и запятой
# print(x)

# x = (9, 8, 7, 6, 5, 4) # создание кортежа, скобки при создании дают наглядное представление что это кортеж
# a, b, c, d, e, f = x # присвоение каждого значения по очереди из кортежа в переменные
# print(a, b, c)

# x = () # создание пустого кортежа при помощи скобок

# x = tuple() # создание пустого кортежа классом tuple
# print(x)

# для заполнения tuple можно использовать любую итерабельную последовательность
# print(tuple([1, 2, 3]), tuple({1, 2, 3}), tuple((1, 2, 3)), tuple('123'))

# кортеж имеет индексацию по аналогии со списками
# print(x[0], x[4])

# хоть кортеж и является не изменным, но если в нём содержится изменяемый тип данных мы может изменить только его
# y = (1, 2, 3, [1, 2], 4)
# y[3].append(7)
# y[3].append(14)
# print(y)

# кортеж можно использовать в качестве ключа для словаря
# a = (1, 2, 3)
# b= {}
# b[a] = 'hello'
# print(b)

# у кортежа очень мало методов, поэтому для его изменения сначало надо
# преобразовать в список, изменить, затем преобразовать обратно в кортеж
# tupl = (9, 8, 7, 6, 5, 4)
# lis = list(tupl)
# lis[0] = 42
# lis.append(31)
# tupl2 = tuple(lis)
# print(tupl2)

# my_tuple = ('python', 'is', 'awesome', 'is')
# print(my_tuple[2]) # обращение к элементу кортежа по индексу
# к кортежам можно применять срез
# print(my_tuple[1:2])

# print(my_tuple + my_tuple) # кортежи можно складывать
# print(my_tuple * 2) # кортежи можно дублировать
# print('is' in my_tuple, 'abcde' in my_tuple) # с помощью in можно проверять находится ли конкретный элемент в кортеже

# при использовании оператора присваивания для изменения изменяемой коллекции
# внутри неизменяемого кортежа возбуждается исключение но при этом значение коллекции изменяется.
# t = (1, 2, [30, 40])
# try:
#     t[2] += [50, 60]
# except TypeError as exc:
#     print(exc)
#     print(t)
# # при использовании метода extend никакого исключения не возбуждается
# g = (1, 2, [30, 40])
# g[2].extend([50, 60])
# print(g)

# функция enumerate превращает каждый элемент списка в кортежи состоящие из индекса и значения
# можем принимать 2арг. в котором указывается с какого индекса начинать отсчёт
# print(list(enumerate([10, 20, 30, 'abcd', '77'], 765)))
# lst = [10, 20, 30, 'abcd', '77']
# strg = 'abcd'
# tpl = (10, 20, 'one', 'two')
# st = {10, 20, 'aa', 'bb'}
# dct = {10:'10', 20:'20', 30:30, 'ade':'eda'}
# for index, value in enumerate(dct):
#     print(index, value)

#########################################
# Методы для работы с кортежами (tuple) #
#########################################

# print(len(my_tuple)) # узнать количество всех элементов в кортеже
# print(my_tuple.count('is')) # узнаём количество элементов по значению
# print(my_tuple.index('is')) # возвращает первый попавшийся индекс искомого элемента (слева на право)
# print(sorted(my_tuple)) # возвращает новый отсортированный список в переменную (родительский не трогает)

################################### Блок Кортежа закончен ###################################

# парсинг файлов
# ('C:\\pyTraining\TestFolder', ['Новая папка (1)', 'Новая папка (2)'], ['Новый текстовый документ 1.txt', 'Новый текстовый документ 2.txt', 'Новый точечный рисунок 1.bmp'])
# import os
# import time
# list = []
# for adress, dirs, files in os.walk("C:\\pyTraining\TestFolder"):
#     # list.append(adress) # пути ко всем папкам
#     for file in files:
#         full = os.path.join(adress, file)
#         # if ".txt" in full:
#         # if time.time() - os.path.getctime(full) < 86400:
#             # list.append(full)
#         # путь ко всем файлам
#         list.append(os.path.join(adress, file))
#     print(list)

#####################
# Работа с классами #
#####################

# class Class:
#     pass
# cls = Class()

# # получить класс у экземпляра можно следующими способами
# print(cls.__class__)
# print(type(cls))

######################
# Работа с функциями #
######################

# def turtle():
#     return 'eggs'

# print(turtle.__class__) # функции являются классами
# pprint(turtle.__class__.__dict__) # которые содержат атрибуты и методы

# print(turtle())
# print(turtle.__call__())
# print(turtle.__call__.__call__())
# print(turtle.__call__.__call__.__call__())

# Функции являются разделяемым объектом который можно использовать
# одновременно в нескольких контекстах равно как экземпляры одного и того же класса.

# def f(): return [1]
# onevar1 = f()
# [onevar2] = f() # с помощью указания списка или кортежа можно автоматически распаковать вернувшийся список
# (onevar3,) = f()
# print(onevar1, onevar2, onevar3)

# функция определения калорийности
# def calorie_calculator(name, get_calorie, spend_calorie):
#     if get_calorie > spend_calorie:
#         msg = name + ' getting fat'
#     else:
#         msg = name + ' lose weight'
#     return msg
# print(calorie_calculator('Arseniy', 2000, 2150))
# person = ['Ivan', 1900, 1200]
# # в функцию можно передавать сразу список с помощью спец символа * перед названием списка
# print(calorie_calculator(*person))

# оператор return возвращает значение в точку запуска функции то есть show2()
# def show2():
#     x = 7 + z
#     return x
# z = 4 # переменная должна быть выше точки запуска функции остальное не важно
# y = show2()
# print(y) # взаимодейстовать с переменной x внутри функции можно только через return
# x = show2() + 1
# print(x)
# z = 6
# t = show2()
# print(t)

# можно записывать дефолтные аргументы и задавать им значение
# def count_list(list, boolean = False, count = 0):
#     if boolean == True:
#         typelist = type(list[5]) # узнём тип элемента списка
#         for i in list:
#             count += 1 # узнём сколько элементов в списке
#         return count, typelist

#     else:
#         for i in list:
#             count += 1
#         return count

# j = [9, 8, 7, 6, "a", 0.4, True]

# передали 2 аргумента вернулось 2 аргумента
# h, p = count_list(j, True)
# print(h, p)

# передали 1 аргумент вернулся 1 аргумент
# h = count_list(j)
# print(h)

# Если требуется распаковать больше значений чем указано переменных,
# остальные значения попадут в переменную список со звёздочкой *
# *x2, y2, z2 = 0, 1
# print(x2, y2, z2)
# x1, *y1, z1 = 0, 1
# print(x1, y1, z1)
# x3, y3, *z3 = 0, 1
# print(x3, y3, z3)
# a, b, *c = 0, 1, 2, 3, 4
# print(a, b, c)

# если перед аргументом записать * то все аргументы прописанные после него превратятся в кортеж
# можно записать аргументы после кортежа если указать в вызове имя аргумента вместе со значением
# def name(h, d, *args, key1, key2):
#     print(h)
#     print(d)
#     print(args)
#     print(key1)
#     print(key2)
# name(1, 2, 3, 4, 5, key1=6, key2=7)

# функция возвращает по одному элементу без повторений
# def exclusive_item(*args, key=False):
#     newlist = []
#     for i in args:
#         for y in i:
#             if y not in newlist:
#                 newlist.append(y)
#     if key:
#         newlist.sort()
#     return newlist


# # args = arguments
# def print_ab(a, b, *args):
#     print(a)
#     print(b)
#     print(args)
# # Передача списка с помощью спец символа * разбивает его поэлементно и отправляет каждый
# # элемент в виде отдельного аргумента. (аналог передачи по индексу lst[0], lst[1] и т.д.)
# lst = [10, 20, 30, 40]
# print_ab(*lst)
# # Если не угадать с количеством передаваемых элементов и объявленых аргументов в функции
# # то получим исключение TypeError, что бы не прописывать каждый аргумент в функции, можно
# # воспользоваться спец символом * уже в функции для включения всех полученных элементов в один кортеж


# # kwargs = keyword arguments
# # если между позиционными a, b и запакованными **kwargs стоит "/"
# # то аргументы из **kwargs автоматически не смогут перейти в a, b
# # тем самым будет вызвана ошибка TypeError

# # все аргументы слева от "/" чисто позиционные, то есть при вызове функции их не надо указывать явно,
# # после "/" можно задавать как неименованные так и именованные аргументы.

# def print_ab2(a, b, /, **kwargs): # нельзя передавать именованные a=1, b=2
# # def print_ab2(a, b, **kwargs): # можно передавать именованные a=1, b=2
#     print('a:', a)
#     print('b:', b)
#     print('kwargs:', kwargs)
# # Таким же способом *dct можно передать ключи словаря, а с помощью двух **dct значения словаря
# # в случае с **dct необходимо явно описывать принимаемые аргументы в функции либо использовать **kwargs
# dct = {'c':10, 'd':20, 'e':30, 'f':40}
# print_ab2(1, 2, **dct)
# print()
# print_ab2(1, 2, c=10, d=20)


# z = [9,8,7]
# x = [8,8,9,7,6,5]
# c = [1,2,3,4,5,6,7,7]

# t = exclusive_item(z, x, c, key=True)
# print(t)

# x = 5
# def name():
#     global x # пезаписываем глобальную переменную вне функции
#     x += 10
#     print(x)
# name()
# print(x)

# x = 5
# def name():
#     x = 10
#     def name2():
#         nonlocal x
#         # nonlocal x # аналог global но использовать можно только во вложенной функции
#         x = 100
#         print(x)
#     name2()
#     print(x)
# name()
# print(x)

# используя 2 global можно прокинуть переменную из вложенной функции в глобальную область видимости файла
# x = 5
# def name():
#     global x
#     x = 10
#     def name2():
#         global x
#         x = 100
#         print(x)
#     name2()
#     print(x)
# name()
# print(x)

# Вычисляем объем цилиндра
# import math
# # константы правильно записывать в верхнем регистре
# PI = math.pi

# def radius():
#     n = float(input("Введите диаметр цилиндра в см: "))
#     n /= 2
#     return n

# def height():
#     m = float(input("Введите высоту цилиндра в см: "))
#     return m

# def volume():
#     r = radius()
#     h = height()
#     s = PI * r ** 2
#     v = s * h
#     return v
# print("Объем цилиндра:", volume(), "см3")

# def massa(g):
#     n = float(input("Удельный вес г/см3: "))
#     return g * n / 1000
# print("Вес цилиндра в кг:", massa(volume()))

#############################################################################################
# Словарь (dict) изменяемая упорядоченная(в python) коллекция элементов с доступом по ключу #
# иногда ещё называют ассоциативным списком или хеш-таблицей.                               #
# в словаре данные всегда привязаны к ключу                                                 #
#                                                                                           #
# ключём в словаре могут быть только неизменяемые типы данных,                              #
# если в кортеже содержится изменяемый тип данных то кортеж не может быть ключём.           #
#############################################################################################

# d = {}
# tpl = ((1, 2, (1, 2, [1, 2])), 1, 2)
# # для ключа словаря можно использовать только полностью не изменяемые типы данных
# # даже глубоко вложенный изменяемый тип данных - список - вызовет ошибку: TypeError: unhashable type: 'list'
# d[tpl] = 'test'

# dict1 = {}
# not_mutalbe_tuple = (4, True)
# dict1[not_mutalbe_tuple] = 'текст'
# print(dict1)
# mutable_tuple = (4, [1, 2])
# dict1[mutable_tuple] = 'текст' # TypeError: unhashable type: 'list'

# d1 = {} # создаём пустой словарь
# d1 = dict() # способ с помощью функции

# d2 = {'name':'Arseniy', 'lang':'ru'}
# d3 = dict(name='Arseniy', lang='ru')
# print(d2, d3)

# d1 = {'a':7}
# print(d1['a']) # вызов по ключу, ключ 'a' значение 7
# d1['b'] = 9 # добавление пары ключ:значение в конец словаря (если такого ключа ещё не сущестует)
# d1['a'] = 4 # изменение значения по ключу (если такой ключ уже существует)
# del d1['b'] # удаление элемента по ключу
# print(d1)

# print(dict(raz=7, dva=9)) # создание словаря с парой ключ:значение

# конструктор класса dict может принимать итераторы с коллекциями из 2 элементов
# и просто коллекции из 2 элементов для создания словаря
# lst1 = ['a', 'b', 'c']
# lst2 = [1, 2, 3]
# print(dict(zip(lst1, lst2)))
# print(dict([('a', 1), ('b', 2), ('c', 3)]))
# print(dict([['a', 1], ['b', 2], ['c', 3]]))


# Генерируем новый словарь на базе старого
# old_dict = {'Hello': 1, 'World': 2}
# print({ '__' + key: val for key, val in old_dict.items() })
# print({ val: key for key, val in old_dict.items() })

# new_dict = {}
# for key in old_dict:
#     new_dict[old_dict[key]] = key
# print(old_dict, new_dict)

# Заменяем ключ в словаре (с помощью удаления старого и создания нового)
# old_dict = {'Hello': 1, 'World': 2}
# print(old_dict, id(old_dict))
# for old_key, old_val in list(old_dict.items()):
#     del old_dict[old_key]
#     old_dict[old_val] = old_key
# print(old_dict, id(old_dict))


# реверс ключей вместе со значениями в словаре
# d = {'a': 1, 'b': 2, 'c': 3}
# print(d)
# d = dict(
#     tuple(
#         zip(
#             reversed(d.keys()),
#             reversed(d.values())
#         )
#     )
# )
# print(d)


# при сравнении словарей сравниваются как ключи так и их значения
# d1 = {'a':4, 'b':4}
# d2 = {'a':4, 'b':4}
# d3 = {'a':4, 'b':3}
# print(d1 == d2, d1 == d3)

# сравнить только ключи
# print(d1.keys() == d2.keys(), d1.keys() == d3.keys())


# d1 = {'a': 1, 'b': 2}
# d2 = {'g': 9, 'b': 4}
# mySet = {'g', 'b'}

# (исключаются дубликаты за счёт преобразования в set)

# объединение словарей
# d3 = d1 | d2
# print(d1, d2, d3)
# d1 |= d2
# print(d1, d2)

# пересечение ключей словарей
# d3 = d1.keys() & d2.keys() # {'b'}
# print(d1, d2, d3)

# разность ключей из первого словаря
# d3 = d1.keys() - d2.keys() # {'a'}
# print(d1, d2, d3)

# разность ключей из двух словарей
# d3 = d1.keys() ^ d2.keys() # {'g', 'a'}
# print(d1, d2, d3)

# все эти операции можно производить между ключами словаря и сетом
# print(d1.keys() | mySet) # {'g', 'a', 'b'}
# print(d1.keys() & mySet) # {'b'}
# print(d1.keys() - mySet) # {'a'}
# print(d1.keys() ^ mySet) # {'g', 'a'}
# так же эти операции можно производить и между .items()
# но только в том случае если все значения в словарях являются неизменяемыми

#########################################
# Методы для работы со словарями (dict) #
#########################################

# https://stackoverflow.com/questions/18552001/accessing-dict-keys-element-by-index-in-python3

# d1 = {1:'one', 2:'two', 3:'three', 4:'four'}

# print(dict.fromkeys([1, 2, 3, 4, 5], 'значение')) # задаём одно значение для ряда ключей
# d1.clear() # удаляет всё из словаря

# print(d1.get('ключ')) # тоже самое что вызов по ключу через квадратные скобки, но если не будет значения вернёт None
# print(d1.get('ключ', 'своё значение')) # Можно изменить None на своё значение

# Возвращает значение выбранного ключа, если такого ключа нету создаёт ключ со значением None и так же возвращает None.
# Если указать через запятую своё значение то оно запишеться вместо None и оно же вернётся
# print(d1.setdefault("имя ключа", "имя значения"))
# print(d1)

# print(d1.pop(3)) # удаляет пару ключ:значение и возвращает значение удалённой пары, является аналогом del словарь[ключ], если пары нету raise KeyError но можно указать дефолтное значение вторым аргументом
# print(d1.popitem()) # удаляет последнюю пару из словаря и возвращает её в виде кортежа (ключ, значение)

# print(d1.items()) # возвращает список с кортежами ключ:значение (нужен для работы с циклом for)
# print(d1.keys()) # возвращает ключи в виде списка (нужен для работы с циклом for) может использоваться как множество, т.к. ключи уникальны
# print(d1.values()) # возващает значения в виде списка (нужен для работы с циклом for)

# new_d = {2:'перезаписали значение двойки', 'профессия':'программист'}
# print(d1)
# d1.update(new_d) # добавить пары ключ:значение из одного словаря в другой, если ключи уже существуют их значения будут перезаписаны
# print(d1)

# a = d1.copy() # создаёт поверхностную копию словаря в новой переменной
# a = dict(d1) # поверхностная копия конструктором
# print(id(a), id(d1))

# print(len(d1)) # узнать количество пар в словаре
# print(2 in d1) # узнать есть ли такой ключ в словаре
# узнать есть ли несколько ключей в словаре
# print({"is_current", "is_previous"} <= dict(is_current=True, is_previous=False).keys())

# print(sorted(d1, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)

################################### ПРИМЕРЫ для Словаря ###################################

# class_room = {'Ivan':17, 'Nikolay':18, 'Klara':16}
# пробегаемся циклом по словарю без методов, получаем только ключи
# for key in class_room:
#     print(key)

# пробегаемся циклом по словарю методом keys(), получаем только ключи
# for key in class_room.keys():
#     print(key)

# пробегаемся циклом по словарю методом values() получаем только значения
# for value in class_room.values():
#     print(value)

# пробегаемся циклом по словарю методом items() получаем ключи и значения
# for key, value in class_room.items():
#     print(key, value)

# проверка есть ли определенный ключ в словаре
# if 'Klara' in class_room:
#     print('Данный ключ уже используеться!')
# else:
#     print('Вы можете использовать данный ключ для создания пары.')


# person = {}
# s = 'IVANOV IVAN Samara SGU 5 4 5 5 4 3 5'
# s = s.split()
# person['lastName'] = s[0]
# person['firstName'] = s[1]
# person['city'] = s[2]
# person['university'] = s[3]
# person['marks'] = []
# for i in s[4:]:
#     person['marks'].append(int(i))
# print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'city': 'Samara', 'university': 'SGU', 'marks': [5, 4, 5, 5, 4, 3, 5]}


# users = {
#     'Alex7': {'password':9856214, 'id':1957},
#     'Jimmy': {'password':1236487, 'id':9654},
#     'Bob33': {'password':9546752, 'id':6453}
# }
# # получить значение конкретного ключа в словаре можно с помощью квадратных скобок и имени ключа:
# print(users['Jimmy']['password'])
# print(users['Bob33']['id'])
# print(users['Alex7'])
# # либо же сразу всех элементов с помощью цикла
# for user_name, user_info in users.items():
#     password = user_info['password']
#     user_id = user_info['id']
#     print(f'Имя пользователя: {user_name} Пароль пользователя: {password} Айди пользователя: {user_id}')


# подсчёт уникальных символов в строке
# s = 'ssss dd  aaa'
# d = {}
# for i in s:
#     if i in d:
#         d[i] += 1
#     else:
#         d[i] = 1
# print(d)


# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# new = {}
# for i in price:
#     # копируем скидку 15% в новый словарь
#     new[i] = round(price[i] * 0.85, 2)
# print(price,"\n")
# print(new)


# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# new = {}
# for key, value in price.items():
#     new[value] = key # инверсия пары ключ значение
# print(price,"\n")
# print(new) # теперь ключём является стоимость товара а значением название


# price = {'meat':3, 'bread':1, 'potato':0.5, 'water':0.2}
# def buy():
#     pay = 0
#     print("\nЧто будете покупать?\n\nВыберите товар из списка ниже:\n\nmeat 3$, bread 1$, potato 0.5$, water 0.2$\n")
#     print("Как определитесь с выбором напишите end\n")
#     while True:
#         enter = input()
#         if enter == "end":
#             print("С вас: " + str(pay) + "$")
#             break
#         if enter in price:
#             pay += price[enter] # получаем значение из словаря price по ключу который введёт пользователь
#         else:
#             print('\nВыберите товар из списка ниже:\n\nmeat 3$, bread 1$, potato 0.5$, water 0.2$\n')
#     return str(pay) + "$"
# buy()

################################### Блок Словаря закончен ###################################

# flag = True
# x = int(input("Введите число: "))
# for i in range(1):
#     # если строка длинная то с помощью скобок её можно перенести
#     flag = ( flag and
#     x % 10 == 0 )
# print(flag)

# flag = False
# x = int(input("Введите число: "))
# for i in range(1):
#     flag = ( x % 10 == 0 ) or flag
# print(flag)

# Вложенные и последовательные if
# две записи снизу идентичны
# x = 6
# if x % 2 == 0:
#     if x % 3 == 0:
#         print('делиться на 6')

# if x % 2 == 0 and x % 3 == 0:
#     print('делиться на 6')

# каскадные конструкции
#  A    B    C    D
# --->|--->|--->|--->
#     0    5   10
# x = int(input("Введите число: "))
# if x < 0:
#     print("A")
# elif x < 5: # x >= 0
#     print("B")
# elif x < 10: # x >= 5
#     print("C")
# else: # x >= 10
#     print("D")

#     ^ y
#  2  |  1
# ----|---- > x
#  3  |  4
# y, x = 0, 0
# if y > 0:
#     if x > 0:
#         print(1)
#     else:
#         print(2)
# else:
#     if x < 0:
#         print(3)
#     else:
#         print(4)

####################
# Работа с файлами #
####################

# Контекстный менеджер with автоматически закрывает файл после работы с ним
# with open('C:\\pyTraining\\TestFolder\\Новый текстовый документ 4.txt', 'r') as file:
#     text = file.read()
#     print(text)

# записываем все пути из 'C:\\pyTraining\\TestFolder' в текстовый документ
# import os
# list_path = []
# for adress, folder, file, in os.walk('C:\\pyTraining\\TestFolder'):
#     for i in file:
#         full_path = os.path.join(adress, i)
#         list_path.append(full_path)
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt', 'w')
# for i in list_path:
#     file.write(i + '\n')
# file.close()

# находим определенный файл
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt')
# for i in file:
#     if 'testfile.exe' in i:
#         print(i)

# text = file.read() # прочитать весь файл целиком
# text = file.readline() # прочитать файл построчно
# text = file.readlines() # прочитать файл построчно и передать данные в переменную в виде списка
# text = file.write('строка текста') # записать в файл строку текста
# print(text)
# file.close() # закрыть файл

# 'r' Открыть для чтения (по умолчанию если не указывать параметр)
# 'w' Открыть для записи, содержимое файла удаляется, если файла нет, создаётся новый
# 'x' Открытие на запись, если файла не существует, иначе исключение.
# 'a' Открыть для дозаписи в конец файла, если файла нет, создаётся новый
# 't' Открыть в текстовом режиме (по умолчанию если не указывать параметр)
# 'b' Открыть в бинарном режиме (двоичном) 'rb', 'wb', 'ab'
# '+' Открыть для чтения и записи 'r+', 'w+', 'a+'

# запись текста в файл
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt', 'w')
# print(file)
# # file.write('текста строка')
# file.close()

# чтение текста из файла
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt')
# text = file.read()
# # text = file.read(5) # если указать число в функции read() можно прочитать определенное количество символов
# # text = file.seek(0) # указав число в функции seek() мы переместимся на чтение с указанного номера символа
# print(text)
# file.close()


# взаимодействие с бинарными файлами
# file = open('C:\\pyTraining\\TestFolder\\testfile.exe', 'rb')
# copy_file = open('C:\\pyTraining\\TestFolder\\Копия testfile.exe', 'wb')

# while True:
#     #                 1024 байт
#     value = file.read(1024*1024) # позволяет устанавливать сколько в ОЗУ во время копирования будет занимать место операция
#     print(value.__sizeof__()) # метод __sizeof__() позволяет узнать какой объем в ОЗУ занимает объект
#     if value.__sizeof__() == 33: # 33 не константа, может быть и другое число
#         break
#     copy_file.write(value)
# file.close()
# copy_file.close()


# # запись файла с определенной кодировкой
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 2.txt', 'w', encoding='utf-8')
# file.write('string текста')
# file.close()
# # если файл записан с необычной кодировской можно указать её для корректного чтения
# file2 = open('C:\\pyTraining\TestFolder\Новый текстовый документ 2.txt', encoding='utf-8')
# print(file2.read())

#######################################################################################################
# Множество (set) неупорядоченная коллекция уникальных элементов (отсутствуют повторяющиеся значения) #
# может состоять только из неизменяемых типов данных: число, строка, кортеж                           #
#######################################################################################################

# создать можно с помощью фигурных скобок
# a = {} # пустые фигурные скобки работают как словарь (dict), если перечислить данные через запятую получится множество
# так же создать множество можно с помощью функции set()
# y = set()
# print({"a", "a", "f", 1, 1, 1, 2, 3, 5, 25, (2, 5), (2, 5)}) # множество автоматически убирает повторяющиеся значения
# преобразуем список с повторяющимися значениями в множество затем обратно в список, тем самым убирая повторяющиеся значения
# print(list(set([1, 1, 2, 2, 3, 3, 4, 4, 5, 5])))

# x_tuple = (1, 2, 3, 4, 5, 6, 7)
# x_list = [1, 2, 3, 4, 5, 6, 7]
# x_dict = {'1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7}
# x_set = {1, 2, 3, 4, 5, 6, 7} # множества работают гораздо быстрее чем остальные типы списков
# # размер списка в памяти
# print(x_tuple.__sizeof__()) # 80
# print(x_list.__sizeof__()) # 96
# print(x_dict.__sizeof__()) # 344
# print(x_set.__sizeof__(), '\n') # 712
# from sys import getsizeof
# print(getsizeof(x_tuple)) # 80
# print(getsizeof(x_list)) # 96
# print(getsizeof(x_dict)) # 344
# print(getsizeof(x_set)) # 712

# Сравнение в скорости работы списка со множеством
# import time
# def f(*args):
#     list_new = []
#     for i in args:
#         for y in i:
#             if y not in list_new:
#                 list_new.append(y)
#     return list_new

# z = list(range(10000))
# x = list(range(5000, 15000))
# c = list(range(10000, 20000))

# start = time.time()
# f(z, x, c)
# stop = time.time() - start
# print('Время работы со списком:', stop)

# start2 = time.time()
# r = set(z)
# t = r.union(set(x), set(c))
# stop2 = time.time() - start2
# print('Время работы с множеством:', stop2)

# так же существует такой тип данных как frozenset, это множество элементы которого нельзя изменять
# print(frozenset([1, 1, "a"]), type(  frozenset([1, 1, "a"])  ))

# с множеством можно работать только при помощи методов

##########################################
# Методы для работы со множествами (set) #
##########################################

# z = {1, 2, 3, 4, 5}
# x = {3, 4, 5, 6, 7}

# при добавлении или объединении значения которые повторяются не будут дублироваться
# z.add(6) # добавить один элемент в множество
# z.discard(4) # удалить один элемент из множества (ничего не делает если такого элемента нет)
# z.remove(6) # удалить один элемент из множества (дропает исключение KeyError если такого элемента нет)
# z.pop() # удалить первый элемент из множества,
# но т.к. в множестве элементы не имеют постоянной позиции, по сути удаляет случайный элемент
# z.clear() # удалить все элементы из множества
# y = z.copy() # поверхностная копия методом
# y = set(z) # поверхностная копия конструктором

# print(id(z), id(y))

# z.update([7, 8]) # добавить значения из итерабильного объекта в множество
# z.update((9, 10))
# z.update({11, 12})
# z.update('ABCD')

# четыре метода реализующих операторы могут принимать в качестве аргументов не только множества,
# но и любые коллекции которые содержат исключительно неизменяемые объекты
# lst1 = [17, 18]; lst2 = [19, 20]
# z.update(x, lst1, lst2)

# z.update(x) # перезаписать объединённые множества в z # аналог z |= x
# y = z.union(x) # объединить множества # аналог y = z | x
# так же для объединения можно использовать синтаксис: y = {*z, *x}

# y = z.intersection(x) # получить повторяющиеся элементы в двух множествах # аналог y = z & x
# z.intersection_update(x) # перезаписать в z пересечение значений # аналог z &= x

# y = z.difference(x) # получить не повторяющиеся элементы из первого множества # аналог y = z - x
# z.difference_update(x) # перезаписать в z не повторяющиеся элементы из первого множества # аналог z -= x

# y = z.symmetric_difference(x) # получить не повторяющиеся элементы из первого и второго множества одновременно # аналог y = z ^ x
# z.symmetric_difference_update(x) # перезаписать в z не повторяющиеся элементы из первого и второго множества одновременно # аналог z ^= x

# print(len(z)) # узнать количество элементов в множестве
# print(4 in z) # узнать есть ли конкретное значение в множестве
# print(z == x) # множества равны

# z = {1, 2, 3}; x = {1, 2}
# print(z > x) # z является надмножеством x
# print(z < x) # z является подмножеством x

# z.issubset(x) # или  z <= x  все элементы z принадлежат x.
# z.issuperset(x) # или  z >= x  аналогично issubset.
# z.isdisjoint(x) # истина, если z и x не имеют общих элементов (не пересекаются).

# print('z:', z)
# print('x:', x)
# print('y:', y)

# print(sorted(z, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)

###############################################################################################
# Строка (str) упорядоченная последовательность символов (присутствуют повторяющиеся символы) #
###############################################################################################

# поставив обратный слэш перед кавычками можно экранировать их
# тем самым вывести этот символ просто в качестве визуального элемента
# print("Я \"Арсений\" всем привет!")
# print('Я "Арсений" всем привет!')

# перенос строки на следующую строку (просто для оптимизации места на экране) (так же работает и для обычного кода)
# s = "qwerty\
# uiopa\
# sdfgh\
# jklzx\
# cvbnm"
# print(s)

# аналог переноса строки с помощью тройных кавчек (""", ''', ```)
# s = """qwerty
# uiopa
# sdfgh
# jklzx
# cvbnm"""
# print(s)

# строки могут сами конкатенироватся даже без '+'
# a = 'первый ' 'второй '   'третий'
# print(a)
# b = ('четвёртый '
#      'пятый '
#      'шестой')
# print(b)

# \n позволяет переносить строку на следующую по настоящему

# экранирование переноса строки изза \n с помощью второго слэша
# x = "https:\www.youtube.com\nexttab"
# x = "https:\www.youtube.com\\nexttab"

# специальный символ r перед строкой запрещает применять управляющие символы в данной строке
# x = r"https:\www.youtube.com\nexttab"
# для работы с путями в виндовс можно использовать r либо везде ставить двойной слэш
# x = 'C:\\Users\\PyHS\\Desktop'
# print(x)

# символы r, f можно совмещать в одной строке
# print(rf'adada{123}bcbc')

# print('\f \v') # гендерные символы

# print('123\r456') # \r возврат в начало текущей строки
# print('123\b\b456') # \b возврат на один символ назад в текущей строке

# экранирование слэш что бы он не экранировал кавычку
# ('D:\')
# ('D:\\')

# сложение строк(конкатенация)
# a = "Привет " + "Мир!"
# print(a)

# Сравнение строк
# print('abc' > 'r') # Получим False т.к. сравнение начинается с 1 символа а 'r' имеет больший порядковый номер чем 'a'
# print(ord('a'), ord('r'), ord('2'), ord('7')) # функция ord позволяет узнать номер символа в таблице ASCII
# print(chr(ord('a')), chr(ord('r'))) # функция chr наоборот переводит номер символа в сам символ
# print('abc' < 'abcd') # если символы в строках одинаковые но одна строка длиннее другой то True будет на стороне более длинной строки

# s = "stroka texta"
# print(s[5]) # получаем конкретный символ по индексу
# print(s[2:6]) # срез строки со 2 по 6 символ
# print(s[3:]) # срез с левой стороны
# print(s[:9]) # срез с правой стороны
# print(s[::2]) # срез символов через символ
# print(s[::-1]) # инвертируем строку с помощью среза
# print(s[-2:]) # срез с конца без необходимости указывать длину строки "abcdef"[-2:] -> "ef"
# print(s[:2]) # срез с конца без необходимости указывать длину строки "abcdef"[:2] -> "ab"
# print(s[:-2]) # срез с конца без необходимости указывать длину строки "abcdef"[:-2] -> "abcd"
# print(s[:len(s)-2]) # срез с конца с указанием длины строки           "abcdef"[:len(s)-2] -> "abcd"

# срез можно создавать и с помощью класса и передавать его в квадратные скобки
# myslice = slice(None, None, -1) # инвертируем строку с помощью класса среза
# print(s[myslice])

# print([0, 1, 2, 3, 4, 5][:-3])
# print([0, 1, 2, 3, 4, 5][slice(None, -3, None)]) # срез с конца без необходимости указывать длину строки
# print([0, 1, 2, 3, 4, 5][::2])
# print([0, 1, 2, 3, 4, 5][slice(None, None, 2)]) # срез символов через символ

# с помощью срезов можно изменять/удалять определённые участки последовательности
# l = list(range(10))
# print(l)
# l[2:5] = [20, 30]
# print(l)
# del l[5:7]
# print(l)
# l[3:2] = [11, 22]
# print(l)
# l[2:5] = [100]
# print(l)

# с помощью срезов можно изменять список присваиванием на месте
# a = [1, 2, 3, 4, 5, 6]
# b = ['A', 'B', 'C']
# a[1::2] = b
# print(a)
# print(b)

# a = [1, 2, 3, 4, 5, 6]
# b = ['A', 'B', 'C']
# a[::2] = b
# print(a)
# print(b)

# a = ['a', 'b', 'c', 'd', 'e', 'f']
# a[::2] = map(str.upper, a[::2])
# print(a)


# инвертируем строку обращаясь по индексу
# text = 'Кошка'
# print(text[4]+text[3]+text[2]+text[1]+text[0])

# инвертируем строку любой длинны с помощью цикла
# cat = 'Кошка'
# tac_table = []
# count = 0

# for letter in range(0, len(cat)):
#     count -= 1
#     tac_table.append(cat[count])

# inverseCat = ''.join(tac_table)
# print(inverseCat)

# инвертируем строку с помощью метода списков reverse()
# cat = 'Кошка'
# # превращаем строку в список с помощью генератора списка
# cat_table = [x for x in cat]
# cat_table.reverse() # применяем метод
# # превращаем инвертированный список обратно в строку
# inverseCat = ''.join(cat_table)
# print(inverseCat)

# cat = 'Кошка'

# print(''.join(list(reversed(cat))).capitalize())

# print(''.join(c for c in reversed(cat)).capitalize())

# print(''.join(cat[i] for i in range(len(cat)-1, -1, -1)).capitalize())

# print(cat[::-1].capitalize())

# cat = list(cat)
# cat.reverse()
# print(''.join(cat).capitalize())

# возвращает True/False в зависимости от того есть ли такой текст в таком порядке символов в проверяемой строке или нет
# print('stra' in s)

#######################################
# Методы для работы со строками (str) #
#######################################

# s = 'Привет мир! Как дела народ?'
# уточнение для методов (find, rindex, count) индексация всегда идёт слева на право
# если указанного символа нет в тексте (find вернёт -1)(index вернёт ValueError)(count вернёт 0)
# (find, index, count) могут принимать доп арг. start, stop с какого и до какого индекса
# print(s.find('д')) # возвращает индекс первого попавшегося искомого символа либо строки из нескольких символов # метод rfind() ищет первый попавшийся символ справа на лево
# print(s.rindex('д')) # идентично с find просто может сыпать разные эрроры # rindex()
# print(s.count('д')) # узнать количество определенных символов
# print(len(s)) # узнать количество всех символов в строке
# print(s.upper()) # переводит все символы в верхний регистр
# print(s.lower()) # переводит все символы в нижний регистр
# print("Grüßen".casefold()) # агрессивно приводит строку к нижнему регистру, заменяя неприводимые символы на их аналоги (например немецкую букву ß на ss)
# print('a'.isupper(), 'A'.islower()) # проверит принадлежит ли символ к проверяемому регистру, вернёт булевое значение
# print('a'.swapcase(), 'A'.swapcase()) # меняет регистр на противоположный (переводит символы верхнего регистра в нижний регистр, а символы нижнего регистра в верхний регистр)
# print(s.capitalize()) # переводит первую букву в строке в верхний регистр а все остальные в нижний регистр
# print(s.title()) # переводит первую букву во всех словах в строке в верхний регистр
# print(s.istitle()) # если в строке большая буква только первая возвращает True иначе False
# print(s.strip()) # по дефолту удаляет неограниченное количество пробелов и преносов строк в начале и конце строки
# если указать символ он сделает тоже самое только с ним. Ещё методы которые убирают только с левой либо с правой стороны (lstrip, rstrip)
# print(s.isalpha()) # если символы являются только буквами возвращает True, иначе False
# print('17'.isdigit()) # если символы являются только числами возвращает True, иначе False
# print('17'.isdecimal()) # проверяет строку, если строка является исключительно десятичной
# print('17'.isnumeric()) # проверяет строку, если строка является исключительно числовой
# print(s.isalnum()) # если строка состоит из букв либо цифр или из букв вместе цифрами возвращает True иначе False
# print(s.replace('е', ' ^_^', 1)) # заменяет выбранный символ на другой, может принимать 3 арг. сколько замен надо произвести
# print(s.split('а')) # разделяет строку на сектора по выбранному символу и возвращает их в виде списка (по умолчанию по пробелам)
# print('111'.rjust(7, '$')) # вставляет символ заполнитель слева от строки # ljust аналогично только справа (по умолчанию заполн. пробел)
# print('abcd'.startswith('ab'), 'abcd'.startswith('ba')) # сравнивает указанный префикс с началом строки возвращает True если префикс совпадает
# print('abcd'.endswith('cd'), 'abcd'.endswith('dc')) # сравнивает указанный префикс с концом строки возвращает True если префикс совпадает
# print(''.isprintable(), '?'.isprintable()) # проверяет что все символы в строке доступны для корректной печати
# метод format позволяет подставлять значения в строку, аналог f-string
# print('текст {0} текст {1}\n'.format('a', 2), 'текст {name} текст {age}\n'.format(name='Arseniy', age=24), 'текст {name} текст\n'.format(**{'name': 'Guido'}))

# format позволяет обращаться к атрибутам переданного объекта при форматировании
# class Response:
#     status_code = 404
#     message = 'Not Found'
# response = Response()
# error_msg = "HTTP error {resp.status_code} - {resp.message}"
# error_msg = error_msg.format(resp=response)
# print(error_msg)

# метод format_map отличается от обычного format тем что не создаёт новый словарь
# и не выбрасывает исключение KeyError за счёт дандер метода __missing__ в случае отсутствия ключа
# class Default(dict):
#     def __missing__(self, key):
#         return key
# print('{name} имя есть а страну не передали {country}'.format_map(Default(name='Guido')))

# s = 'café'
# print('строка:', s, len(s))
# s = s.encode('utf8') # метод позволяет преобразовывать строку в байт-строку
# # количество символов != количеству байт, один символ может занимать более 1 байта.
# print('строка после кодирования:', s, len(s))
# s = s.decode('utf8') # метод позволяет преобразовывать байт-строку в строку
# print('строка после декодирования:', s, len(s))

# метод строк translate позволяет заменить некоторые знаки или удалить их
# в методе str.maketrans 1 и 2 арг. отвечает за то какой знак на какой заменять, 3 арг что удалить из строки
# с помощью метода punctuation из модуля string получаем строку со знаками пунктуации
# from string import punctuation
# print(s.translate(str.maketrans('', '', punctuation)))
# print(punctuation)

# print(''.join(list(reversed('98765')))) # пример

# print(repr('строка вместе с одинарными кавычками\n\n')) # возвращает строку вместе с кавычками и управляющими знаками
# print('строка вместе с одинарными кавычками\n\n'.__repr__())

# метод строк isidentifier и функция iskeyword позволяют проверить,
# можно ли использовать данное имя для объявления, переменной, функции, класса
# то есть не зарезервировано ли оно самим языком.
# from keyword import iskeyword
# s = 'class'
# print(s.isidentifier() and iskeyword(s))

# функцию max и min можно использовать и для вычисления самой длинной строки передав в аргумент key функцию len
# print(max('aa', 'aaa', key=len))
# print(min('aa', 'aaa', key=len))
# либо даже так, возвращаем ключ максимального значения из словаря:
# from collections import Counter
# print(max(Counter([2,2,1,1,1,2,2]).items(), key=lambda tuple: tuple[1])[0])

# так же max можно использовать для сравнения строк, функция будет взвращать <class 'str'>
# сравнение происходит по номеру каждого символа слево на право по таблице ASCII
# print(max(['111', '444', '333']), type(max(['111', '444', '333'])))
# print(ord('1'), ord('4'), ord('@'))

# найти указанное количество максимальных чисел в коллекции в отсортированном виде
# from heapq import nlargest
# print(nlargest(3, [900, 7, 45, 12, 66, 17, 69]))
# # Эквивалентно:
# print(sorted([900, 7, 45, 12, 66, 17, 69], reverse=True)[:3])

# так же для обработки исключения ValueError возникаемого при передаче пустой коллекции в функцию,
# можно указать параметр default, который будет использован в качестве единственного значения при возникновении исключения.
# nums1 = nums2 = []
# print(min(set(nums1) & set(nums2), default=-1))
# nums1, nums2 = [1,2,3], [2,4]
# print(min(set(nums1) & set(nums2), default=-1))

# print(sorted(s)) # возвращает новый отсортированный список в переменную (родительский не трогает)
# print(sorted(s, key=str.lower)) # может принимать в качестве key методы сортируемого объекта в данном случае строки

# a = ['ZZZ 800', 'aaa 45', 'eee 43', 'DDD 800', 'BBB 43', 'www 14']
# # сортировка чисел в строке по возврастанию, сортировка букв по алфавиту без учёта регистра
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower())))

# # тоже самое только сортировка чисел по убыванию с помощью -int
# print(sorted(a, key=lambda x: (-int(x.split()[1]), x.split()[0].lower())))

# # тоже самое только сортировка как чисел так и букв по убыванию с помощью аргумента reverse
# print(sorted(a, key=lambda x: (int(x.split()[1]), x.split()[0].lower()), reverse=True))


# исключение(фильтрация) элементов последовательности по условию в переданной функции
# print(list(filter(lambda x: x > 4, [1, 2, 3, 4, 5, 6, 7])))


# reduce() применяет функцию к элементам последовательности, сводя ее к единственному значению
# from functools import reduce
# data = {
#     "a": {
#         "b": {
#             "c": {
#                 "mykey": "myvalue"
#             }
#         }
#     }
# }
# print(reduce(dict.get, ["a", "b", "c", "mykey"], data))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4]))
# print(reduce(lambda x, y: x + y, [1, 2, 3, 4], 7)) # третий арг. добавится к итоговому результату


# класс map принимает итерируемую последовательность вторым аргументом и функцию первым
# через которую будет прогонятся каждый элемент этой последовательности
# на выходе мы получим итератор с результатом выполнения по которому можно пройтись циклом либо просто обернуть в класс list()
# x = [0, 1, -10, 5, -8, 3]
# print(list(map(abs, x)))

# класс map совместно с методом split позволяет принимать аргументы от функции input
# написанные через пробел и преобразовывать их в другой тип
# n1, n2, n3 = map(int, input('Введите три числа через пробел: ').split()) # 1 2 3
# print('числа:', n1, n2, n3)
# n4, n5, n6 = map(str, input('Введите три буквы через пробел: ').split()) # a b c
# print('буквы:', n4, n5, n6)

# вместо int/str можно передать свою функцию или методы
# n00, n01, n02 = map(str.upper, ['hello', 'hi', 'good morning'])
# print(n00, n01, n02)

# аналогичный код функции map()
# n7, n8, n9 = [int(x) for x in input('Введите три числа через пробел: ').split()]
# print('числа:', n7, n8, n9)
# n10, n11, n12 = [str(x) for x in input('Введите три буквы через пробел: ').split()]
# print('буквы:', n10, n11, n12)


# английский алфавит и цифры
# import string
# letters = string.ascii_letters
# digits = string.digits
# print(letters, digits)


# алгоритм генерации русского алфавита
# letters = ''.join([chr(c) for c in range(ord('а'), ord('а')+6)] + [chr(ord('а')+33)] + [chr(c) for c in range(ord('а')+6, ord('а')+32)])
# print(letters)


# # добавление текста в строку при помощи кортежа и спец символа %s
# d = "Hello %s I am %s and im %s good" % ('Arseniy', 'Python', 'Чертовски')
# print(d)

# a = "Какой то текст %(count)d %(items)s" % {"count": 19, "items": {"my_key1": "my_value1", "my_key2": "my_value2"}}
# print(a)
# b = "Какой то текст %(my_key)s" % {"my_key": "my_value"}
# print(b)
# c = "Какой то текст %s" % "ещё текст"
# print(c)
# d = "Какое то число %d" % 174
# print(d)

# # добавление текста в строку с помощью метода format() и спец символа {}
# # в данном примере строки в методе format представляют из себя кортеж
# # обращаясь по индексам к данному кортежу можно подставлять текст в любое место строки
# a = "Hello {0} I am {1} and im {2} good".format('Arseniy', 'Python', 'Чертовски')
# print(a)
# # в данном примере строки в методе format мы передали в качестве аргументов
# # соответственно в строку и нужно подставлять ключи этих аргументов
# x = "Hello {name} I am {lang} and im {phrase} good".format(name='Arseniy', lang='Python', phrase='Чертовски')
# print(x)

# функция format работает аналогично методу format
# print(format(1.2749, '0.2f'))
# print(format(42, 'b')) # перевести десятичное число в двоичное
# print(format(42, 'x')) # перевести десятичное число в шестнадцатиричное
# print(format(2 / 3, '.1%'))


# третий вариант самый лучший с помощью спец символа f перед строкой и фигурных скобок в которых можно записывать всё что угодно
# name = 'Arseniy'
# print(f'Hello {name} I can do it in f-string {5*5}')
# print(f'{name=}') # с помощью знака = после переменной, получаем имя=значение


# print(f'{3.8 :.2f}') # Количество знаков после точки для дробного числа
# print(f'{1030.2 :,.2f}') # Разделитель для целого числа и количество знаков после точки для дробного числа
# print(f'{1120 :,d}') # Вывести целое число, если число больше 999 то ставится запятая в качестве разделителя
# print(f'{3.8 :.1%}') # Умножает значение на 100, позволяет задать количество знаков после точки и добавляет знак процента в конце
# print(f'{200 :b}') # Представление числа в двоичном коде
# s = 'abcdef'
# print(f'{s :.3s}') # Макс количество символов отображаемых в строке, обрезание происходит справа на лево

# запись :<int> позволяет устанавливать количество пробелов
# которые могут быть заполнены символами до смещения элементов после заполнения
# так же можно указать направление этого смещения (по умолчанию вправо)
# print(repr(
#     f'| {"":15} | {"abcdefgh":12} | {"abcdefgh":>12} |'
# ))
# print(repr(
#     f'| {"ffffff   ffffff":15} | {"abcdefgh":>12} | {"abcdefgh":12} |'
# ))

# !r предоставляет объект в f-string будто бы он обёрнут в функцию repr()
# x = '1'
# print(f'without !r {x}', f'   with !r {x!r}', f'   with repr {repr(x)}')
# %r тоже самое что !r
# y = '2'
# print('without %s' % y, 'with %r' % y)


# a = ((1024*1024)*42) / 1024
# print(a)
# aa = f'{a :,.0f}'[:-1]
# print(aa)


# метод repr у библиотеки reprlib позволяет сокращать выводимые последовательности,
# до 4-6 элементов заменяя оставшуюся часть на элипсис.
# import reprlib
# L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# D = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g'}
# print(L)
# print(reprlib.repr(L))
# print(list(zip(L, L)))
# print(reprlib.repr(list(zip(L, L))))
# print(D)
# print(reprlib.repr(D))

################################### Блок Строки закончен ###################################

# raise ValueError('текст') # оператор вызова исключения с кастомным текстом

# exc = ZeroDivisionError("Деление на нуль")
# raise exc

# Обработка ошибок в пайтон

# while True:
#     # пробуем исполнить код, если нет ошибок то он исполняется здесь
#     try:
#         enter = float(input("Введите число: "))
#         print("\nИсполнение try")
#     # если тип ошибки ValueError выполняем такой код
#     # можно не прописывать определенную ошибку тогда except: исполниться при любой ошибке
#     except ValueError:
#         print("\nexcept ValueError")
#     # если тип ошибки ZeroDivisionError то выполняем другой код
#     except ZeroDivisionError:
#         print("\nexcept ZeroDivisionError")
#     # обработка нескольких исключений в одном блоке except
#     except (ValueError, ZeroDivisionError):
#         print("\nexcept ValueError, ZeroDivisionError")
#     # не обязательный оператор else он исполниться только если успешно выполнен блок try и не задействован блок except
#     else:
#         print("Исполнение else")
#     # не обязательный оператор finally он исполниться и при try и при except
#     finally:
#         print("Исполнение finally")

# Обрабатывая одно исключение, обрабатываются все исключения ниже по иерархии
# например обрабатывая исключение LookupError обрабатываются IndexError, KeyError

# поиск необходимого исключения в блоке except идёт сверху вниз,
# кто первый найдётся будь он даже родительским исключением и будет использован для обработки.
# try:
#     2 + '2'
# except ValueError:
#     print('except ValueError:')
# except TypeError:
#     print('except TypeError:')
# except Exception:
#     print('except Exception:')

# try:
#     2 + '2'
# except Exception:
#     print('except Exception:')
# except TypeError:
#     print('except TypeError:')

# # так же можно записывать сразу несколько видов исключений в одну конструкцию except в виде кортежа.
# try:
#     2 + '2'
# except (ValueError, TypeError):
#     print('except (ValueError, TypeError):')

# try:
#     try:
#         raise ValueError('сообщение об исключении')
#     except Exception as exc:
#         print("INNER try-except", exc)
#         # для того чтобы внешний блок узнал о исключении во внутреннем
#         # можно рерайзнуть исключение и оно попадёт во внешний блок
#         raise
# except Exception as exc:
#     print("OUTER try-except", exc)


# Кастомный класс исключения
# class MyException(Exception):
#     """Информация о классе"""
#     def __init__(self, *args):
#         self.message = args[0] if args else None

#     def __str__(self):
#         return f"Ошибка: {self.message}"

# raise MyException("Сообщение")


# при райсе без класса исключения в блоке except, будет происходить не явный ре-райс отловленного исключения
# try:
#     raise KeyError("Нет такого ключа")
# except KeyError:
#     raise
# # или так
# try:
#     raise KeyError("Нет такого ключа")
# except:
#     raise
# # явный ре-райс отловленного исключения
# try:
#     raise KeyError("Нет такого ключа")
# except KeyError as exc:
#     raise exc


# Иерархия встроенных классов исключений

# BaseException - базовое исключение, от которого берут начало все остальные.
#     SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы.
#     KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
#     GeneratorExit - порождается при вызове метода close объекта generator.
#     Exception - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
#         StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
#         ArithmeticError - арифметическая ошибка.
#             FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
#             OverflowError - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
#             ZeroDivisionError - деление на ноль.
#         AssertionError - выражение в функции assert ложно.
#         AttributeError - объект не имеет данного атрибута (значения или метода).
#         BufferError - операция, связанная с буфером, не может быть выполнена.
#         EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
#         ImportError - не удалось импортирование модуля или его атрибута.
#         LookupError - некорректный индекс или ключ.
#             IndexError - индекс не входит в диапазон элементов.
#             KeyError - несуществующий ключ (в словаре, множестве или другом объекте).
#         MemoryError - недостаточно памяти.
#         NameError - не найдено переменной с таким именем.
#             UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
#         OSError - ошибка, связанная с системой.
#             BlockingIOError
#             ChildProcessError - неудача при операции с дочерним процессом.
#             ConnectionError - базовый класс для исключений, связанных с подключениями.
#                 BrokenPipeError
#                 ConnectionAbortedError
#                 ConnectionRefusedError
#                 ConnectionResetError
#             FileExistsError - попытка создания файла или директории, которая уже существует.
#             FileNotFoundError - файл или директория не существует.
#             InterruptedError - системный вызов прерван входящим сигналом.
#             IsADirectoryError - ожидался файл, но это директория.
#             NotADirectoryError - ожидалась директория, но это файл.
#             PermissionError - не хватает прав доступа.
#             ProcessLookupError - указанного процесса не существует.
#             TimeoutError - закончилось время ожидания.
#         ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
#         RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
#         NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
#         SyntaxError - синтаксическая ошибка.
#             IndentationError - неправильные отступы.
#                 TabError - смешивание в отступах табуляции и пробелов.
#         SystemError - внутренняя ошибка.
#         TypeError - операция применена к объекту несоответствующего типа.
#         ValueError - функция получает аргумент правильного типа, но некорректного значения.
#         UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках.
#             UnicodeEncodeError - исключение, связанное с кодированием unicode.
#             UnicodeDecodeError - исключение, связанное с декодированием unicode.
#             UnicodeTranslateError - исключение, связанное с переводом unicode.
#         Warning - предупреждение.


# import sys
# url_list = [
#     'TestFolder\\Новая папка (3)\\Новый текстовый документ 1.txt',
#     'TestFolder\\Новая папка (3)\\Новый текстовый документ 2.txt',
#     'TestFolder\\Новая папка (3)\\Новый текстовый документ 3.txt', # типо битый файл
#     'TestFolder\\Новая папка (3)\\Новый текстовый документ 4.txt'
# ]
# list_info = []
# list_defect = []

# try:
#     for url in url_list:
#         try:
#             r = open(url, encoding='utf-8')
#             list_info.append(r.read())
#             print('try')
#         except Exception:
#             list_defect.append(url)
#             print('except')
#             sys.exit() # имитируем выход из программы перед чтением последнего элемента в списке
#             continue
# finally:
#     r = open('TestFolder\\Новая папка (3)\\save.txt', 'a')
#     for i in list_info:
#         r.write(i)
#     r.write(str(list_defect))
#     r.close()
#     print("Я всё записал не смотря ни на что!")

# ниже указано 2 по сути аналогичных метода автоматического сохранения содержимого файла при ошибке
# оба метода запишут данные только до строки с ошибкой
# try:
#     r = open('TestFolder\\Новая папка (4)\\Новый текстовый документ 1.txt', 'a')
#     r.write('something' + '\n')
#     10/0 # нарошно допускаем ошибку
#     r.write('записываем ещё что-то')
# finally:
#     r.close()
#     print('запись завершена')

# with open('TestFolder\\Новая папка (4)\\Новый текстовый документ 1.txt', 'a') as r:
#     r.write('something' + '\n')
#     10/0 # нарошно допускаем ошибку
#     r.write('записываем ещё что-то')
# print("запись завершена")

################ СОЗДАНИЕ СВОЕГО ПАКЕТА ################

# https://packaging.python.org/en/latest/tutorials/packaging-projects/
# https://pypi.org/
# https://test.pypi.org/

# Перед запуском workflows/*.yml файла необходимо создать "Издательство" чтобы не прокидывать токен

# Установка генератора дустрибутивов
# py -m pip install --upgrade build
# Создание дистрибутива с помощью pyproject.toml
# py -m build
# ИЛИ
# Создание дистрибутива с помощью setup.py
# python setup.py sdist bdist_wheel

# Установка удаленного загрузчика
# py -m pip install --upgrade twine
# Загрузка локального дистрибутива в тестовый репозиторий pypi
# (Если не указывать флаг --repository то дистрибутив будет загружен в настоящий pypi)
# py -m twine upload --repository testpypi dist/*
# Загрузка локального дистрибутива в настоящий репозиторий pypi
# py -m twine upload dist/*

# Установить локально загруженный пакет с тестового репозитория pypi (установка без зависимостей)
# py -m pip install --index-url https://test.pypi.org/simple/ --no-deps drf-spectacular-websocket==1.0.2

# Можно установить локально из файла для теста
# pip install dist/your_file.whl

#################### PYINSTALLER # pip install pyinstaller ####################

# pyinstaller --version

# Если использовать параметр -D тогда .exe и все файлы будут помещены в одну общую папку и открытие будет происходить в командной строке
# для корректной работы необходимо перекинуть все исходные файлы программы в созданную папку

# Если использовать параметр -w тогда .exe и все файлы будут помещены в одну общую папку и открытие будет происходить без командной строки
# для корректной работы необходимо перекинуть все исходные файлы программы в созданную папку

# Если использовать параметр -F тогда будет создан один .exe файл и открытие будет происходить в командной строке
# для корректной работы необходимо перекинуть .exe к исходным файлам программы

# Можно задать имя отличное от компилируемого файла написанное слитно параметром -n новое_имя

# ( первый способ ) можно в ручную добавлять или убирать запуск консоли --windowed с консолью --noconsole без консоли
# ( второй способ ) для запуска без консоли необходимо поменять расширение файла с .py на .pyw

# можно задать кастомную иконку для .exe файла параметром --icon=имяиконки.ico

# преобразуем картинки в .ico файл # https://www.icoconverter.com/

# команда на живом примере: # pyinstaller -F --noconsole --icon=gear80x80.ico -n BackUpFolders BUFcore.py

#################### Команды терминала ####################

# проверяем версию пайтон # python -V либо # python --version
# проверяем версию пип # pip -V
# обновить пип # python -m pip install --upgrade pip

# установка новых либ # pip install имяЛибы
# установка определенной версии либы # pip intall имяЛибы==номерВерсии
# обновление установленных либ # pip install -U pip имяЛибы
# обновление глобального установщика pip # c:\python3-8-9\python.exe -m pip install -U pip pip
# обновление локального установщика pip:
# c:/путь/к/проекту/venv/scripts/python.exe -m pip install --upgrade pip

# удаление установленных либ # pip uninstall имяЛибы -y
# удаление всех либ прописанных в файле requirements.txt с помощью команды # pip uninstall -r requirements.txt -y
# или # pip uninstall -r requirements.txt
# проверяем установленные либы в глобальном окружении # pip list

# Если pip выдаёт ошибку: Fatal error in launcher: Unable to create process using
# выполняем 3 команды по очереди (возможно поможет):
# python -m pip uninstall pip
# python -m ensurepip
# python -m pip install -U "pip<10"

# Если pip выдаёт ошибку: Fatal error in launcher: Unable to create process using
# возможно поможет удаление и создание нового виртуального окружения, если оно конечно используется

# Узнать версию конкретной библиотеки: pip show <название либы>

# проверяем установленные либы в виртуальном окружении # pip freeze
# если дропает ошибку: 'Fatal error in launcher: Unable to create process using' тогда: python -m pip freeze

# создаём текстовый файл с используемыми либами в проекте с виртуальным окружением # pip freeze > requirements.txt
# если дропает ошибку: 'Fatal error in launcher: Unable to create process using' тогда: python -m pip freeze > requirements.txt

# создаём текстовый файл с используемыми либами в глобальном окружении # pip list > C:/pyTraining/requirements.txt

# создаём виртуальное окружение с системной версией пайтона # python -m venv venv
# либо с необходимой(должна быть установлена на компьютере) # py -3.8 -m venv venv
# виртуальное окружение необходимо для того что бы загружать в него либы необходимые для работы скрипта

# активация виртуального окружения # venv/Scripts/activate.bat
# деактивация виртуального окружения # venv/Scripts/deactivate.bat
# либо сочетание клавиш в vsCode # ctrl+shift+P # затем Python: Выбор интерпритатора

# установка либ с помощь файла зависимостей # pip install -r requirements.txt

#############
# Замыкания #
#############

# Замыкание это когда переменная из блока внешней функции
# запоминается для всех последующих вызовов вложенной функции
# def closure(old):
#     lst = []
#     def inner(new):
#         res = new * old
#         print(f'inside inner: {lst=}, {new=} * {old=} = {res=}')
#         lst.append(res)
#         return res
#     return inner

# inner = closure(2)
# res1 = inner(4)
# res2 = inner(4)
# res3 = inner(4)

# print('co_varnames:', inner.__code__.co_varnames) # здесь храняться переменные из функции inner
# print('co_freevars:', inner.__code__.co_freevars) # здесь храняться свободные переменные из функции closure (попавшие в замыкание)
# print('closure cell_contents:', inner.__closure__[1].cell_contents) # здесь храниться значение переменной old
# print('inner cell_contents:', inner.__closure__[0].cell_contents) # здесь храниться список lst

##############
# Декораторы #
##############

# from functools import wraps

# # декоратор это функция которая позволяет обернуть другую функцию в свой код при этом не трогая оригинальный код
# def decorator(func_name):
#     # декоратор @wraps нужен для того что бы __name__ и __doc__ отображали информацию о родительской функции а не об обёртке
#     @wraps(func_name)
#     def wrapper():
#         """Документация тестовой функции wrapper"""
#         print('Выполнился код декоратора перед вызовом родительской функции make()') # выполняем код декоратора
#         print('Аргумент func_name ==', func_name) # переданный аргумент представляет собой имя функции
#         func_name() # выполненяем функцию make()
#         print('Выполнился код декоратора после вызова родительской функции make()') # продолжаем выполнение кода декоратора
#     return wrapper # возвращаем имя обёртки. make = wrapper()

# # как аргумент в функцию decorator передаётся имя функции make
# @decorator # make = decorator(make)
# def make():
#     """Документация тестовой функции make"""
#     print('Выполнился код внутри функции make()')
# print('Запускаем функцию make() под декоратором @decorator')
# make()
# print('Код выполнен.')

# print('\nИмя функции:', make.__name__)
# print('Документация функции:', make.__doc__)


# Можно записать декоратор с пробросом дополнительных аргументов, выглядеть это будет так,
# просто добавляется ещё один внешний декоратор с помощью которого и декорируется необходимая
# функция, аргументы передеанные в этот внешний декоратор при обёртывании и попадут в _args, _kwargs
# def outer_decor(*_args, **_kwargs):
#     def decorator(func):
#         def wrapper(*args, **kwargs):
#             print('аргументы переданные в outer_decor при обёртывании:', _args, _kwargs)
#             print('аргументы переданные в функцию function:', args, kwargs)
#             func(*args, **kwargs)
#         return wrapper
#     return decorator

# @outer_decor(1, 2, a=3, b=4)
# def function(text, num, key_word_key):
#     pass
# function('abc', 777, key_word_key='key_word_value')

# # тот же самый декоратор но без синтаксического сахара:
# def function(text, num, key_word_key):
#     pass
# function_outer_decor = outer_decor(1, 2, a=3, b=4)(function)
# function_outer_decor('abc', 777, key_word_key='key_word_value')
# # можно даже записать в одну строку:
# outer_decor(1, 2, a=3, b=4)(function)('abc', 777, key_word_key='key_word_value')


# Декораторы функций выполняются сразу после импорта модуля,
# но сами декорируемые функции только в результате явного вызова.
# def a():
#     print('a')

# def d(f):
#     print('d')
#     return f

# @d
# def b():
#     print('b')


# Композиция декораторов, несколько декораторов ведут себя как вложенные вызовы функций
# @alpha
# @beta
# def my_fn():
#     ...
# # запись выше семантически эквивалентна
# my_fn = alpha(beta(my_fn))


# Декоратор который кэширует результат вычислений функции func_name
# и в случае повторного запроса с такими же входными аргументами
# не будет заного считать а вернёт кэшированный результат.
# cache = {}

# def decor_func(func):

#     def wrapper(*args, **kwargs):

#         if args in cache:
#             #print(f'return cache | {args=}')
#             return cache[args]

#         result = func(*args)

#         cache[args] = result

#         #print(f'create cache | {args=}')

#         return result

#     return wrapper

# @decor_func
# def func(x):
#     print("Wait im calculating")
#     return x*x + 1

# print('return:', func(4), '  cache:', cache)
# print('return:', func(4), '  cache:', cache)
# print('return:', func(4), '  cache:', cache)
# print('return:', func(6), '  cache:', cache)
# print('return:', func(6), '  cache:', cache)

# @decor_func
# def fibonacci(n):
#     if n < 2:
#         return n
#     return fibonacci(n - 2) + fibonacci(n - 1)
# print('return:', fibonacci(40))


# from time import perf_counter
# def clock(func):
#     """Декоратор хронометрирующий каждый вызов декорируемой функции
#     и печатающий затраченное время, переданные аргументы и результат."""
#     def clocked(*args, **kwargs):
#         time_stamp = perf_counter()
#         result = func(*args, **kwargs)
#         elapsed = perf_counter() - time_stamp
#         arg_lst = [repr(arg) for arg in args]
#         arg_lst.extend(f'{key}={val!r}' for key, val in kwargs.items())
#         arg_str = ', '.join(arg_lst)
#         print(f'[{elapsed:0.4f}s] {func.__name__}({arg_str}) -> {result!r}')
#         return result
#     return clocked

# # Декоратор cache для кэширования результата, переопределяет декоратор lru_cache
# # в котором доступен параметр maxsize который позволяет указать
# # максимальный размер списка элементов которые будут кэшироваться.
# from functools import cache, lru_cache
# @cache
# @clock
# def fibonacci(n):
#     if n < 2:
#         return n
#     return fibonacci(n - 2) + fibonacci(n - 1)
# print('return:', fibonacci(22))


# Декоратор класс для декорирования функции
# class Repeater:
#     def __init__(self, count):
#         print('Repeater def __init__', count)
#         self.count = count

#     def __call__(self, func):
#         print('Repeater def __call__', func)
#         def wrapper(*args, **kwargs):
#             print('Repeater def wrapper BEFORE', args, kwargs)
#             res = func(*args, **kwargs)
#             print('Repeater def wrapper AFTER', res)
#             res *= self.count
#             return res
#         return wrapper

# @Repeater(3)
# def foo(a, b):
#     print('def foo', a, b)
#     return a + b

# print('return:', foo(2, 2))


# Декоратор функция для декорирования класса
# def add_calc(cls):
#     print('def add_calc:', cls)

#     def calc(self):
#         print('def calc:', self)
#         return 42

#     cls.calc = calc
#     return cls

# @add_calc
# class MyClass:
#     def __init__(self, a, b):
#         print("MyClass def __init__:", a, b)

# my_obj = MyClass(17, 'Hello')
# print(my_obj.calc())


# Декоратор класс для декорирования класса
# class MyDecorator:
#     def __init__(self, cls):
#         print('MyDecorator def __init__', cls)
#         self.cls = cls

#     def __call__(self, *args, **kwargs):
#         print('MyDecorator def __call__', args, kwargs)
#         return self.cls(*args, **kwargs)

# @MyDecorator
# class MyClass:
#     def __init__(self, a, b):
#         print('MyClass def __init__', a, b)
#         self.a = a
#         self.b = b

#     def get_a_plus_b(self):
#         print('MyClass def get_a_plus_b')
#         return self.a + self.b

# obj = MyClass(2, 2)
# print(obj.get_a_plus_b())

##################################################################################
# Генераторы списков, словарей, множеств. Выражение-генератор, Функция-генератор #
##################################################################################

# lst = [9, 8, 7, 4, 5, 6, 3, 2, 1, 5, 5]

# первый способ создания изменённого списка
# lst0 = []
# for x in lst:
#     lst0.append(x * 2)
# print('lst0:', lst0)

# второй способ создания изменённого списка с помощью генератора-списков (list comprehension) (работает быстрее обычного цикла)

# отличия от обычного цикла в том что сначало берём весь код в скобки
# (зависит от того в какой список мы хотим автоматически преобразовать последовательность)
# затем пишется действие которое будем производить с полученным значением в переменной
# затем for (переменная в которую присваивается значение при итерации) in (итерируемая последовательность)
# lst1 = [x * 2 for x in lst] # создание списка
# print('lst1:', lst1)

# # выражение-генератор (generator expression) можно проитерировать только один раз
# lst2 = (x * 2 for x in lst) # создание выражения генератора
# print('lst2:', lst2)
# # # т.к. выражение-генератор является итератором из него можно получить элементы по очереди с помощью функции next()
# print('next1:', next(lst2))
# print('next2:', next(lst2))
# print('next3:', next(lst2))
# # либо же с помощью цикла
# for item in lst2:
#     print('item:', item)

# итераторы и генераторы можно распаковывать с помощью символа звёздочки
# iterator = iter('12345')
# print(hasattr(iterator, '__next__'), hasattr(iterator, '__iter__'), iterator, *iterator)
# generator = (x for x in '12345')
# print(hasattr(iterator, '__next__'), hasattr(iterator, '__iter__'), generator, *generator)

# выражение-генератор (generator expression) позволяет экономить место в ОЗУ т.к.
# не создаётся огромный список как с генератором списка
# отличие при создании только в круглых скобках
# a = [x**2 for x in range(1, 10001, 2)] # генератор списка
# b = (x**2 for x in range(1, 10001, 2)) # выражение-генератор
# print('генератор списка:', a.__sizeof__())
# print('выражение генератор:', b.__sizeof__())

# lst3 = {x * 2 for x in lst} # создание генератора-множества (set comprehension)
# print('lst3:', lst3)

# в словаре отличие лишь в том что сначало надо записать значение которое пойдёт в качестве ключа
# и поставить двоеточие, затем всё как и с другими типами списков
# lst4 = {x / 2: x * 2 for x in lst} # создание генератора-словаря (dict comprehension)
# print('lst4:', lst4)

# преобразование первых букв в заглавные и изменение строкового значение на инт
# d = {'джефф безос': '177', 'илон маск': '126', 'бернар арно': '150', 'билл гейтс': '124'}
# d2 = {k.title(): int(v) for k, v in d.items()}
# print(d)
# print(d2)

# lst = ['a', 1, 'b', 2, 'c', 3, 'd', 4, 'e', 5, 'f', 6]
# d = {lst[i]: lst[i+1] for i in range(0, len(lst)-1, 2)}
# print(d)

# Добавление условий в генератор
# условие записывается после записи (итерируемой последовательности) если нужен только 'if'
# lst5 = [x for x in [9, 8, 7, 4, 5, 6, 3, 2, 1, 5, 5] if x % 2 == 0]
# print('lst5:', lst5)

# условие записывается перед записью (итерируемой последовательности) если нужен как 'if' так и 'else'
# lst6 = [x if x % 2 == 0 else x ** x for x in [9, 8, 7, 4, 5, 6, 3, 2, 1, 5, 5]]
# print('lst6:', lst6)

# ещё пример со строкой
# lst6 = [x * 4 for x in 'a1b2c3d4e5' if x.isalpha()]
# print('lst6:', lst6)

# Если нужно условие if по результату которого мы уже переходим ко вложенным if else запись такая:
# четные числа range(0-9): [0, 2, 4, 6, 8]
# порядок выполнения условий: (во второе и третье условие попадают только четные числа которые прошли первое условие)
# #    |  второе | |  третье |                    |   первое  |
# x = [n if n == 8 else n * 20 for n in range(10) if n % 2 == 0]
# print(x) # [0, 40, 80, 120, 8]

# пример генераторов со вложенными циклами

# lst1 = [x * y for x in [2, 3, 4, 5] for y in [1, 2, 3] if y % 2 == 1]
# lst2 = []
# for x in [2, 3, 4, 5]:
#     for y in [1, 2, 3]:
#         if y % 2 == 1:
#             lst2.append(x * y)
# print(lst1, lst2)

# lst3 = [[x * y for x in [2, 3, 4, 5]] for y in [1, 2, 3] if y % 2 == 1]
# lst4 = []
# for y in [1, 2, 3]:
#     lst = []

#     for x in [2, 3, 4, 5]:
#         lst.append(x * y)

#     if y % 2 == 1:
#         lst4.append(lst)
# print(lst3, lst4)


# парсер .txt файлов на компьютере
# import os
# all_files = [os.path.join(folders_path, files) for folders_path, list_folders, list_files in os.walk('C:\\pyTraining\\TestFolder')
#                                                for files in list_files if '.txt' in files]
# print(all_files)
# print('Количество файлов:', len(all_files))

# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# # 1 способ
# new_price = {}
# for key in price.keys():
#     new_price[key] = round(price[key] * 0.85, 2) # создаём новый список на основе старого с применением скидки 15%
# print(new_price)
# # 2 способ
# new_price2 = {key: round(price[key] * 0.85, 2) for key in price.keys()}
# print(new_price2)

# sites = ['https:\\www.сайт.com', 'https:\\www.какойтосайт.net',
#     'https:\\www.левыйсайт.com', 'https:\\www.другойсайт.com',
#     'https:\\www.сайтишка.net', 'https:\\www.сайтец.org']
# # индекс 0 = https:   индекс 1 = www.сайт.com
# com_sites = [site.split('\\')[1] for site in sites if '.com' in site]
# print(com_sites)


# обычная функция записывает все прочтённые данные в список list_text тем самым сильно засоряя ОЗУ
# def some():
#     list_text = []
#     with open('C:\\pyTraining\\TestFolder\\Новая папка (4)\\text.txt', encoding='utf-8') as file:
#         for text in file:
#             list_text.append(text)
#     return list_text
# for text in some():
#     print(text.split())

# функция генератор выдаёт значения по очереди тем самым не засоряя ОЗУ
# если прописан оператор yield то пайтон создаёт из этой функции объект генератор
# если мы запустим эту функцию в цикле for который будет запрашивать по 1 значению за раз
# эта функция будет выдавать по 1 значению для каждого цикла for
# def some():
#     with open('C:\\pyTraining\\TestFolder\\Новая папка (4)\\text.txt', encoding='utf-8') as file:
#         for text in file:
#             yield text # замена оператора return
# <class 'generator'> <generator object some at 0x000001EFCE31ECF0> строка текста
# print(type(some()),                     some(),                     next(some()))
# for text in some():
#     print('for:', text.split())

# # можно запрашивать по одному значению из генератора с помощью функции next
# text = some()
# print('next:', next(text).split())
# print('next:', next(text).split())
# print('next:', next(text).split())


# def func():
#     yield 1
#     yield 2
#     yield 3
# f = func()
# print(next(f))
# print(next(f))
# print(next(f))
# # print(next(f)) # exception: StopIteration


# def first():
#     yield 1
#     yield 2

# def second():
#     # импорт генератора в генератор
#     yield from first()
#     yield 3
#     yield 4
# s = second()
# for i in s:
#     print(i)

##################
# lambda функции #
##################

# Структура lambda функции
# даём имя функции        принимаем аргументы : работаем с аргументами
# lambda_function_name = lambda arg1, arg2, arg3: arg1 + arg2 + arg3
# в lambda функции уже стоит невидимый return который вернёт результат работы функции
# вызываем функцию по имени переменной и передаём аргументы
# print(lambda_function_name(2, 2, 2))

# Структура lambda функции с условиями
# сначало записывается объект (в нашем случае это arg1) который вернётся в результате выполнения оператора if
# затем сам оператор if и условие для его выполнения
# затем оператор else и объект который вернётся в результате выполнения оператора else
# lambda_function_name = lambda arg1, arg2: arg1 if arg1 > arg2 else arg1 + arg2
# print('вызов с арг. (4, 6) =', lambda_function_name(4, 6), '\nвызов с арг. (6, 4) =', lambda_function_name(6, 4))

# Применение lambda функции в сравнении с обычной функцией
# имеем список который необходимо отсортировать по возврастанию последнего символа в числе
# первый пример с использованием lambda функции второй с использованием обычной функции, результат одинаков
# lst = [78, 56, 23, 8, 54512, 65, 95, 2354, 41, 5000]
# srt_lst1 = sorted(lst, key=lambda x: x % 10)
# print(srt_lst1)

# def sort_func(x):
#     return x % 10
# srt_lst2 = sorted(lst, key=sort_func)
# print(srt_lst2)

# фильтрация элементов списка по условию
# функцию filter можно использовать для создания нового списка
# на основе старого исключив какие то значения
# lst = [['Adam', 29], ['Jonny', 16], ['Jess', 24], ['Karl', 7], ['Antony', 32]]
# new_lst = list(filter(lambda age: age[1] >= 18, lst))
# print(new_lst)

# исключаем буквы с помощью метода isdigit в функции filter
# print(list(filter(str.isdigit, '432jfdsHFDS343f')))

# a = b = c = d = e = True
# # a = b = c = d = False or None
# # e = True
# all и any принимают на вход только коллекцию
# # Если один из элементов True(истинно) условие срабатывает
# if any((a, b, c, d, e)):
#     print('Any', any((a, b, c, d, e)))
# # Если все элементы True(истинны) условие срабатывает
# if all((a, b, c, d, e)):
#     print('All', all((a, b, c, d, e)))

# функция all может принимать выражение-генератор,
# и как только какое-нибудь сравнение возвращает False,
# так all сразу возвращает False
# L1 = [1, 2, 3]
# L2 = [1, 3, 3]
# print(all(a == b for a, b in zip(L1, L2)))


# узнать версию OS
# from sys import platform
# print(platform)


# Узнать локализацию виндовс системы, возвращает: ru_RU или en_US
# import locale
# import ctypes
# windll = ctypes.windll.kernel32
# localization = locale.windows_locale[windll.GetUserDefaultUILanguage()]
# print(localization)

# print(' ') # символ пустышка, создаёт пробелы
# print('⚠️ ▶️ ❌ 🏁 👍 ✔ █ ✖')
# print('⮜ ⮞ ⮝ ⮟')

# Матрицы # https://silvertests.ru/GuideView.aspx?id=34372

# index 0 1 2 3
#     |---------
#   0 | 1 2 4 29
#   1 | 3 4 6 1

# arr = [
#     [1, 2, 4, 29],
#     [3, 4, 6, 1]
# ]

# Создание матрицы с тремя столбцами по два элемента каждый
# N = 3
# M = 2
# A = []
# for i in range(N):
#     A.append([0]*M)
# print(A)

# сделать то же самое можно с помощью генератора
# N = 3
# M = 2
# A = [ [0]*M for i in range(N) ]

# Заполнение матрицы
# for i in range(N):
#     for j in range(M):
#         A[i][j] = 6

# Вывод матрицы по индексам на экран для удобства восприятия
# for i in range(len(A)):        # возвращает количество строк в матрице
#     for j in range(len(A[i])): # возвращает количество элементов в строке
#         print(A[i][j], end=' ')
#     print()                    # делаем переход на новую строку

# Вывод матрицы по значениям списка на экран для удобства восприятия
# for row in A:               # делаем перебор всех строк матрицы
#     for elem in row:        # перебираем все элементы в строке
#         print(elem, end=' ')
#     print()                 # делаем переход на новую строку

# Вывод матрицы по значениям списка на экран для удобства восприятия
# for row in A:
#     print(' '.join(list(map(str, row))))

# встроенный модуль copy позволяет создавать копии: словарей, множеств, списков, пользовательских классов (мб что-то ещё)
# import copy
# test_1 = [1, 2, 3, [1, 2, 3]]
# test_copy = copy.copy(test_1)
# print(test_1, test_copy)
# # [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]]

# test_copy[3].append(4)
# print(test_1, test_copy)
# # [1, 2, 3, [1, 2, 3, 4]] [1, 2, 3, [1, 2, 3, 4]]

# test_1 = [1, 2, 3, [1, 2, 3]]
# test_deepcopy = copy.deepcopy(test_1)
# test_deepcopy[3].append(4)
# print(test_1, test_deepcopy)
# # [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3, 4]]


# for num in range(39):
#     summ = 0
#     summ2 = 0

#     for n in str(num):
#         summ += int(n)

#     for n in str(summ):
#         summ2 += int(n)

#     if summ2 == 2:
#         print(num, summ2)


# Подмена строки по полу человека
# gender = {
#     'male':'Дорогой',
#     'female':'Дорогая'
# }

# data = [
#     ['Семён', 'Семёнович', 32.56, 'male'],
#     ['Тамара', 'Ивановна', 13.12, 'female'],
#     ['Михаил', 'Анатольевич', 238.12, 'male']
# ]

# for name, mid_name, balance, gen in data:
#     text = f'{gender[gen]} {name} {mid_name}, баланс вашего лицевого счёта составляет {balance} руб.'
#     print(text)


# Алгоритм Евклида для нахождения НОД (наибольшего общего делителя) двух целых чисел
# a = int(input('Введите большее число: '))
# b = int(input('Введите меньшее число: '))

# while b > 0:

#     c = a % b
#     a = b
#     b = c

# print(a)


# Нахождение всех делителей числа
# n = int(input())
# i = 1
# a = []
# while i * i <= n:
#     if n % i == 0:
#         a.append(i)
#         if i != n // i:
#             a.append(n // i)
#     i += 1
# a.sort()
# print(a)


# Треугольник Паскаля
# n = int(input('Введите число: '))
# triangle = []

# for i in range(n+1):
#     triangle.append([1]+[0] * n)

# for i in range(1, n+1):
#     for j in range(1, i+1):
#         triangle[i][j] = triangle[i-1][j] + triangle[i-1][j-1]

# for i in range(0, n+1):
#     for j in range(0, n+1): # i+1 # убрать нули по диагонали
#         if triangle[i][j] < 10:
#             print(triangle[i][j], end='  ')
#         else:
#             print(triangle[i][j], end=' ')
#     print()


# Рекурсия

# def recursion(x):
#     print(x)
#     if x == 1: return
#     return recursion(x - 1)
# print(recursion(5))

# def get_factorial(x):
#     print('x:', x)
#     if x == 1: return x
#     return x * get_factorial(x - 1)

# print(get_factorial(5))
# print(5*4*3*2)

# rnd_str = 'LItBeoFLcSGBOFQxMHoIuDDWcqcVgkcRoAeocXO'

# count = 0
# new_rnd_str = ''
# for char in rnd_str:
#     count += 1
#     if count <= len(rnd_str) / 2:
#         if len(rnd_str) % 2 == 0 and count == len(rnd_str) / 2:
#             new_rnd_str += char
#         else:
#             new_rnd_str += char + '('
#     elif count == len(rnd_str):
#         new_rnd_str += char
#     else:
#         new_rnd_str += char + ')'
# print(new_rnd_str)


# # count = 0
# # new_rnd_str = ''
# def rec_add_hooks(rnd_str, count=0, new_rnd_str=''): # вместо global переменных можно укзать параметры функции
#     # global count
#     # global new_rnd_str

#     if count + 1 <= len(rnd_str) / 2:

#         if len(rnd_str) % 2 == 0 and count + 1 == len(rnd_str) / 2:
#             new_rnd_str += rnd_str[count]
#         else:
#             new_rnd_str += rnd_str[count] + '('

#     elif count + 1 == len(rnd_str):
#         new_rnd_str += rnd_str[count]
#         return new_rnd_str

#     else:
#         new_rnd_str += rnd_str[count] + ')'

#     count += 1

#     if count < len(rnd_str):
#         return rec_add_hooks(rnd_str, count, new_rnd_str)

# print(rec_add_hooks(rnd_str))


# def rec(rnd_str):
#     if len(rnd_str) == 1 or len(rnd_str) == 2:
#         return rnd_str
#     return rnd_str[0] + '(' + rec(rnd_str[1:-1]) + ')' + rnd_str[-1]
# print(rec(rnd_str))


# a = [1, [3, [4, [3, 4]], [2, 3, [4]]], 2, [2, 3, 4, [3, 4, [2, 3], 5]]]

# def rec(spicok, level=1):
#     print(*spicok, 'level =', level)
#     for i in spicok:
#         if type(i) == list:
#             rec(i, level + 1)
# rec(a)


# import os
# path = 'C:\\pyTraining\\TestFolder'
# def obxod_file(path, level=1):
#     print('Level =', level, 'Content:', os.listdir(path))
#     for i in os.listdir(path):
#         if os.path.isdir(path + '\\' + i):
#             print('Спускаемся', path + '\\' + i)
#             obxod_file(path + '\\' + i, level + 1)
#             print('Возвращаемся в', path)
# obxod_file(path)


# получить текущую дату и время
# from datetime import datetime as dt
# print(dt.now())

# получить разницу времени между вызовами функции
# from time import perf_counter as pc
# print(pc())

# удобный для восприятия вывод принтов, на примере словаря
# from pprint import pprint
# pprint(locals())

# перезагрузка модуля
# from importlib import reload
# reload(название_модуля)


# Имена объектов с префиксом _ или __ не будут автоматически импортированы из модуля,
# для импорта требуется явно указать их имена.
# G = globals()
# from test_module.file1 import *
# print('BEFORE:', G.get('var'), G.get('func'), G.get('Class'))
# print('BEFORE:', G.get('_var'), G.get('__var'), G.get('_func'), G.get('__func'), G.get('_Class'), G.get('__Class'))
# from test_module.file1 import _var, __var, _func, __func, _Class, __Class
# print('AFTER: ', G.get('var'), G.get('func'), G.get('Class'))
# print('AFTER: ', G.get('_var'), G.get('__var'), G.get('_func'), G.get('__func'), G.get('_Class'), G.get('__Class'))


# узнать версию пайтон внутри скрипта
# from sys import version_info
# print(version_info)
# if version_info < (3, 10):
#     print('Python version < 3.10')


# класс Counter служит для подсчёта повторений в последовательностях
# from collections import Counter
# s = 'abracadabra'
# w = ['Donald', 'Mickey', 'Donald', 'Mickey', 'Mickey']
# k = (1, 2, 3, 3, 3, 2, 4, 1, 1)
# print(Counter(s))
# print(Counter(w))
# print(Counter(k))


# класс defaultdict служит для исключения ошибки NameError при вызове несуществующего ключа
# при данном вызове создастся ключ с запрошенным именем и значением в виде того что вы передадите в класс defaultdict
# from collections import defaultdict

# # dct = {}
# # dct['a'] # NameError

# INT = defaultdict(int)
# print(INT)
# INT['key']
# print(INT)

# LIST = defaultdict(list)
# print(LIST)
# LIST['key']
# print(LIST)

# STR = defaultdict(str)
# print(STR)
# STR['key']
# print(STR)

# TUPLE = defaultdict(tuple)
# print(TUPLE)
# TUPLE['key']
# print(TUPLE)

# SET = defaultdict(set)
# print(SET)
# SET['key']
# print(SET)


# класс namedtuple, позволяет создавать класс с именованными значениями кортежа
# from collections import namedtuple
# Point = namedtuple('Point', 'x y z')
# pnt = Point(43, 57, 24)
# print(pnt.x, pnt.y, pnt.z) # появляется возможность обращаться как к атрибутам класса
# print(pnt._asdict()) # представление именнованного кортежа в виде словаря
# print(pnt._replace(y='текст')) # изменение значения атрибута

# # обычный кортеж с обращением по индексам
# point = (43, 57, 24)
# print(point[0], point[1], point[2])

# # ещё пример
# Person = namedtuple('Person', 'name surname date country')
# prsn = Person('Megan', 'Jones', '1998-07-16', 'Bolivia')
# print(prsn.name, prsn.surname, prsn.date, prsn.country)
# print(prsn._asdict())
# print(prsn._replace(date='текст'))

# # обычный кортеж с обращением по индексам
# person = ('Megan', 'Jones', '1998-07-16', 'Bolivia')
# print(person[0], person[1], person[2], person[3])

# Шпаргалка по аннотациям: https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html
# # Аннотации, на работу никак не влияют, визуально дают понять к какому типу должен принадлежать объект
# a: int = 100
# # стрелкой указывается тип объекта который должна вернуть функция
# def some(a: int, b: int = 40) -> int:
#     return a + b
# print(some(a))
# print(some.__annotations__)

# # с помощью библиотеки typing можно явно указывать какие объекты будут содержатся в итерируемом объекте
# from typing import List, Dict, Set, Tuple, Any, Optional, Union
# d: Dict[str, int] = {'a': 100, 'b': 200}
# # так же для функции
# def some2(lst: List[str]):
#     for item in lst:
#         print(item)
# some2(['a', 'b', 'c'])
# print(some2.__annotations__)

# e: Any = [1, 'a', 'b', 2, True, 1.74] # Any означает то что может содержатся любой тип

# def some3(arg: Optional[int] = None): # Optional означает то что arg по дефолту содержит NoneType но опционально может содержать int
#     print(arg)
# some3()
# some3(30)
# print(some3.__annotations__)

# def some4(arg: Union[int, str]): # Union означает то что arg может содержать один из двух типов
#     print(arg)
# some4(60)
# some4("41")
# print(some4.__annotations__)

# [python >= 3.10] можно указывать несколько типов через логическое OR(или)
# myvar: int | float | str = 17
# myvar: Any[int, float, str] # аналог из библиотеки typing

# с [python >= 3.9] простые типы можно аннотировать по умолчанию
# без необходимости импорта специализированных классов из библиотеки typing
# для версий 3.6 и более можно импортировать from __future__ import annotations
# lst: list[str] = ['a', 'b', 'c']
# tpl: tuple[int] = (1, 2, 3)
# st: set[str] = {'a', 'b', 'c'}

# Чтобы включить в аннотацию последовательность неопределённой длины
# необходимо указать многоточие после типа
# def f(arg: tuple[int, ...]): pass


# from numbers import Integral
# # Декоратор singledispatch создаёт функцию для объединения нескольких функций в одну обобщённую
# from functools import singledispatch
# # Используется когда необходимо выполнять разную операцию в зависимости от типа передаваемого аргумента
# # Появляется возможность разделить множество ветвей логики на разные функции.

# @singledispatch
# def my_func(obj: object) -> None:
#     """Базовая функция которая принимает все объекты
#     с типами для которых не определены специализированные функции."""
#     print('my_func:', obj)

# @my_func.register
# def _(arg: str) -> str:
#     return arg + arg

# @my_func.register
# def _(arg: Integral) -> Integral:
#     return arg + arg

# @my_func.register(bool)
# def _(arg):
#     return arg

# print('return:', my_func([1, 2]))
# print('return:', my_func('1'))
# print('return:', my_func(1))
# print('return:', my_func(False))


# from functools import partial

# def A(*args, **kwargs):
#     print("A:", args, kwargs)

# # partial позволяет создать новую функцию на основе другой функции
# # с установкой аргументов по умолчанию,
# # без необходимости их передачи в новосозданную функцию
# patched_A = partial(A, arg1=1, arg2=2)
# patched_A(arg3=3)


#########################
# Транслитерация текста #
#########################

# from pytils.translit import translify # pip install pytils
# def transliteration(text):
#     return translify(text).replace(' ', '-').lower()
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# from transliterate import translit # pip install transliterate
# def transliteration(text):
#     return translit(text, reversed=True).replace(' ', '-').lower()
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# from transliterate import slugify # pip install transliterate
# def transliteration(text):
#     slug_text = slugify(text)
#     if not slug_text:
#         text = text.replace(' ', '-').lower()
#         return text
#     return slug_text
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# def transliteration(text):
#     text = text.replace(' ', '-').lower()
#     cyrillic = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
#     latin = 'a|b|v|g|d|e|e|zh|z|i|i|k|l|m|n|o|p|r|s|t|u|f|kh|tc|ch|sh|shch||y||e|iu|ia'.split('|')
#     trantab = {k:v for k, v in zip(cyrillic, latin)}
#     newtext = ''
#     for ch in text:
#         casefunc = str.capitalize if ch.isupper() else str.lower
#         newtext += casefunc(trantab.get(ch.lower(), ch))
#     return newtext
# print(transliteration('Дарова бичары   ыы ГЫГЫ 07ada'), '|', transliteration('DAROVA HAHA   addaad 62вФВФ'))


# Получить прирост в процентах между двух чисел:
# Вычитаем из большего числа меньшее число и делим получившееся число на большее число.
# x = (18 - 11) / 18
# print(x)
# 7 равно 38% прироста

# x = (18 / 11) * 100
# print(x)

# Получить разницу в процентах между числами
# max_row = 108540
# rows_recorded = 20602
# percent_diff = (rows_recorded * 100) / max_row
# print(f'{percent_diff:.1f}')

# Вычислить какое значение составляет указанный процент у значения
# some_len = 20
# percent = 50
# print(some_len / 100 * percent) # 50% от числа 20 это число 10

# max_val = 27000
# cur_val = 21000
# print(cur_val * 100 / max_val)
# print(cur_val / max_val * 100)

# Вычислить среднее значение у списка чисел
# lst = [3, 3, 3, 8, 8, 8]
# average = sum(lst) / len(lst)
# print(average)

# Вычислить цену товара с учётом процента скидки
# price = 200 # $
# discount = 10 # %
# discount_price = price - (price * (discount / 100))
# print(f'{price}$ - {discount}% = {discount_price}$')


# MarkDown - Язык разметки
# class MarkDown:
#     """

#     # Заголовок первого уровня.
#     ## Заголовок второго уровня.
#     ### Заголовок третьего уровня.
#     #### Заголовок четвёртого уровня.
#     ##### Заголовок пятого уровня.
#     ###### Заголовок шестого уровня.

#     Ссылка с текстом ссылкой в тултипе
#     [открыть её](https://doka.guide)

#     Ссылка с кастомным текстом в тултипе
#     [открыть её2](https://doka.guide 'Энциклопедия про web-dev')

#     ---
#     Полосы отделяющие визуально

#     ---

#     Разметка в табличном стиле, двоеточие : выравнивает текст внутри колонки

#     |Раз|Два|Три|
#     |:-:|:-:|:-:|
#     |1|Текст1|118|
#     |22|шесть|92|
#     |3|Текст3|7|

#     - текст после минуса

#     - заголовок
#         - подзаголовок1 после табуляции
#         - подзаголовок2 после табуляции

#     >>> Отображение цветных подсказок get_avatar -> str

#     """


# При сравнении пересечения каунтеров, сравниваются значения ключей присутствующих в обоих каунтерах
# тем не менее если в одном из каунтеров будет ключ которого нет в другом он будет проигнорирован при сравнении
# from collections import Counter
# c1 = Counter('aabbcc')
# c2 = Counter('aabbcc')
# c3 = Counter('aabbc')
# c4 = Counter('aabbccdd')
# print(c1, c2, (c1 & c2), (c1 & c2 == c1))
# print(c1, c3, (c1 & c2), (c1 & c3 == c1))
# print(c1, c4, (c1 & c2), (c1 & c4 == c1))


# zip завёрнутый в enumerate
# array = [-4, 2, 5, 6, 18, 19]
# for index, (l_num, r_num) in enumerate(zip(array, array[1:])):
#     print(index, (l_num, r_num))


# lst1 = [1, 3, 5]
# lst2 = [2, 4, 6]
# # слияние двух списков наложением с использованием zip
# res = []
# for a, b in zip(lst1, lst2):
#     res.append(a)
#     res.append(b)
# print(res)

# # слияние двух списков наложением с использованием zip
# res = [num for tpl in zip(lst1, lst2) for num in tpl]
# print(res)


# zip_longest позволяет работать с коллекциями разной длины, в отличие от zip
# заполняя более короткие коллекции заполнителем fillvalue, по умолчанию None
# from itertools import zip_longest
# l1 = [1, 2, 3, 4]
# l2 = [5, 6, 7]
# print('zip_longest:', list(zip_longest(l1, l2, fillvalue='MYVALUE')))
# print('zip_longest:', list(zip_longest(l1, l2)))
# print('zip:        ', list(zip(l1, l2)))


# cycle создает бесконечный итератор, возвращающий элементы
# из итерируемой последовательности до бесконечности по кругу
# from itertools import cycle
# _cycle = cycle(range(5)) # [0, 1, 2, 3, 4]
# for i, j in enumerate(_cycle):
#     print(j, end=' ')
#     if i > 13:
#         break
# # 0 1 2 3 4 0 1 2 3 4 0 1 2 3 4


# https://docs-python.ru/standart-library/modul-collections-python/klass-deque-modulja-collections/
# from collections import deque
# dq = deque('abcd') # создать список на основе итерируемой последовательности
# print(dq)
# dq.appendleft(44) # добавить элемент в начало списка
# dq.popleft() # удалить первый элемент списка
# dq.extendleft('987') # добавить итерируемую последовательность в начало списка
# print(dq)

# lst = list('abcd')
# print(lst)
# lst.insert(0, 44)
# lst.pop(0)
# print(lst)


# алгоритм поиска в ширину
# from collections import deque
# def search_name_end_letter(name, graph): # O(V+E) # V - количество вершин E - количество рёбер

#     search_queue: deque = deque() # создаём экземпляр очереди
#     search_queue += graph[name] # добавляем в очередь друзей человека с которых начнём поиск
#     searched_persons = [] # этот массив используется для отслеживания уже проверенных людей

#     while search_queue: # пока очередь не пуста
#         person = search_queue.popleft() # из очереди извлекается первый человек

#         if not person in searched_persons: # человек проверяется только в том случае, если он не проверялся ранее

#             if person[-1] == 't': # проверяем заканчивается ли имя у этого человека на букву '?'

#                 # подсчитать количество рёбер/родителей до стартового узла
#                 searched_persons += [name]
#                 def get_parents_count(person, counter=0, persons=[]):
#                     for people in searched_persons:
#                         if person in graph[people]:
#                             print('person:', person)
#                             return get_parents_count(people, counter+1, persons+[person,'-РЕБРО-'])
#                     print('person:', name)
#                     return persons+[name], counter
#                 return get_parents_count(person), 'рёбер'
#                 # return person

#             else: # нет не заканчивается
#                 search_queue += graph[person] # все друзья этого человека добавляются в очередь поиска
#                 searched_persons.append(person) # человек помечается как уже проверенный

#     return False # если выполнение дошло до этой строки, значит, в очереди нет продавца манго

# graph = {
#     'arseniy': ['alice', 'bob', 'claire'],
#     'alice': ['peggy'],
#     'bob': ['anuj', 'peggy'],
#     'claire': ['thom', 'jonny'],
#     'peggy': [],
#     'anuj': [],
#     'thom': ['albert'],
#     'jonny': [],
#     'albert': []
# }
# print('return:', search_name_end_letter('arseniy', graph))


# Тестирование через assert
# def f(a: int, b: int) -> int:
#     return a * b

# def test_f():
#     # если условие не выполняется, в качестве значения у AssertionError
#     # выводится результат выполнения f(2, 2) записаный после запятой
#     assert f(2, 2) == 3, f(2, 2)
# test_f()


# Оценка сложности алгоритмов с помощью нотации - биг O
# биг О - это относительное представление сложности алгоритмов
# https://danielmiessler.com/images/big-o-chart-tutorial-bazar-aymptotic-notations-1.png
# https://wiki.python.org/moin/TimeComplexity

# ------------------------------------------------------------------------------------------------------------------#
### Константная сложность: O(1) ###

# если создать объект, распечатать объект, получить сумму и т.д.
# array = [1,2,3,4]
# print(array)
# print(array[-1])
# print(sum(array))
# def f(): pass
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### Логорифмическая сложность: O(log N) ###

# sorted_array = [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# задача найти число 100 в *отсортированном* списке
# если использовать бинарный поиск
# (деление каждого последующего списка по полам и сравнение последнего элемента первой части и первого элемента второй части с искомым числом)
# сложность будет равна: O(log N)

# находим число в пять шагов
# N = 16    # [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# N = 8     # [1,2,5,7,8,11,16,19], [21,22,23,27,28,100,105,203]
# N = 4     # [21,22,23,27], [28,100,105,203]
# N = 2     # [28,100], [105,203] # число найдено за четыре шага из возможных пяти
# N = 1     #

#     /\
#   19  21
#        \
#        /\
#      27  28
#           \
#           /\
#        100  105
#         /

# Двоичный или Бинарный поиск в *отсортированном* списке, в пайтон это список
# print(f'index:  0  1  2  3  4  5   6   7   8   9   10  11  12  13   14   15')
# A = [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# print("array:", A)

# # искомое число
# target = 99

# # объявляем первый последний и центральный индексы
# left = 0
# right = len(A) - 1
# mid = (left + right) // 2

# # Выполняем итерации до тех пор пока значение в списке по индексу mid не станет равным целевому числу
# # и левая граница не встретится с правой
# while A[mid] != target and left < right:

#     # если целевое число больше значения в списке по индексу mid
#     # тогда двигаем левую границу вправо
#     if A[mid] < target:
#         left = mid + 1
#     # иначе двигаем правую границу влево
#     else:
#         right = mid - 1

#     # после того как новые границы определены, заного вычисляем центр
#     mid = (left + right) // 2

# #print(f'{A[mid] = }  {target = }')
# if A[mid] == target:
#     print("target:", target, "index:", mid)
# else:
#     print("target:", target, "not found")


# def binary_search(list, item):
#     low = 0
#     high = len(list) - 1

#     while low <= high:

#         mid = (low + high) // 2

#         if list[mid] == item:
#             return mid

#         if list[mid] > item:
#             high = mid - 1
#         else:
#             low = mid + 1

#     return None

# print(f'index:  0  1  2  3  4  5   6   7   8   9   10  11  12  13   14   15')
# A = [1,2,5,7,8,11,16,19,21,22,23,27,28,100,105,203]
# print('array:', A)
# print('return index:', binary_search(A, 100))
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### Линейная сложность: O(N) ###

# если пройтись в цикле по какому то списку, N будет равен количеству объектов списка
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 = 10
# N = len(array)
# for i in range(len(array)):
#     summ += array[i]
# print(summ)
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### O(2*N) где 2 количество циклов а N длинна последовательности
# но т.к. в big O natation константы отбрасываются, отбрасываем и получается O(N) ###

# for i in range(10):
#     pass
# for i in range(10):
#     pass
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### Квадратичная сложность: O(N^2) либо другая запись O(N2) ###

# если использовать цикл вложенный в другой цикл, N будет равен количеству объектов списка умноженному на себя 2 раза: 4*4
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 * 4 = 40
# N = 0    # 4 * 4 = 16
# for i in range(len(array)):
#     for j in range(len(array)):
#         summ += array[i]
#         N += 1
# print(summ, N)

# хоть во втором цикле каждый раз мы проходим на 1 элемент меньше всё равно записывается как O(N^2) а не O(N^2/2)
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 * 2 = 20
# N = 0    # (4 * 2) + 2 = 10
# for i in range(len(array)):
#     for j in range(i, len(array)):
#         summ += array[i]
#         N += 1
# print(summ, N)
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### O(N^2+M) где M количество последовательных циклов
# но т.к. в big O natation константы отбрасываются, отбрасываем и получается O(N^2) ###

# for i in range(10):
#     for j in range(10):
#         pass
# for i in range(10):
#     pass
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### Кубическая сложность: O(N^3) либо другая запись O(N3) ###

# если использовать 3 вложенных цикла, N будет равен количеству объектов списка умноженному на себя 3 раза: 4*4*4
# array = [1,2,3,4]
# summ = 0 # 1+2+3+4 * 16 = 160
# N = 0 # 4*4*4 = 64
# for i in range(len(array)):
#     for j in range(len(array)):
#         for k in range(len(array)):
#             summ += array[i]
#             N += 1
# print(summ, N)
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### Экспоненциальная сложность: O(2^N) ###

# def get_fib(x):
#     print(x)
#     if x <= 1: return x
#     return get_fib(x - 1) + get_fib(x - 2)
# get_fib(7)
# ------------------------------------------------------------------------------------------------------------------#

# ------------------------------------------------------------------------------------------------------------------#
### Факториальная сложность: O(N!) ###
# ! означает факториал

# N! = 3   # 3*2*1 = 6
# N! = 5   # 5*4*3*2*1 = 120
# ------------------------------------------------------------------------------------------------------------------#


# генерация рандомного hex цвета
# from random import randint
# random_hex_color = '#%06x' % randint(0, 0xFFFFFF)
# print('random_hex_color:', random_hex_color)
# random_hex_color = '#%06X' % randint(0, 256**3-1) # большие буквы
# random_hex_color = '#%06x' % randint(0, 256**3-1) # маленькие буквы
# print('random_hex_color:', random_hex_color, randint(0, 256**3-1))


# тернарный оператор в python
# a = 'a'
# b = 'b'

# condition = True
# result = a if condition else b
# print(result)

# condition = False
# result = a if condition else b
# print(result)

# в качестве заглушки результата можно использовать любые типы данных, а так же эллипсис
# result = 1 if 0 else ...
# print(result)


# Работа с системой
# import subprocess
# import os
# process = subprocess.Popen("C:\\Program Files\\Redis\\redis-server.exe", stdin=subprocess.PIPE, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
# process = subprocess.Popen("C:\\Program Files\\Redis\\redis-server.exe", stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
# result = subprocess.run(["C:\\Program Files\\Redis\\redis-server.exe"])
# os.startfile(r'C:\Windows\system32\cmd.exe')


# def f1(): print(1)
# def f2(): print(2)
# print(f1() and f2()) # сначала 1 потом None
# print(0 or '5')      # 5
# print(10 and [])     # []

# print(False or False) # False
# print(True or True)   # True
# print(True or False)  # True
# print(False or True)  # True

# print(False and False) # False
# print(True and True)   # True
# print(True and False)  # False
# print(False and True)  # False


# Python может складывать int числа бесконечной длины (float только короткие)
# a = '9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
# b = '9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
# print(sum(map(int, (a, b))))
# print(int(a) + int(b))


# Проверить скорость выполнения блока кода
# code = """
# for i in range(10):
#     pass
# """
# import timeit
# elapsed_time = timeit.timeit(code, number=100)/100
# print(elapsed_time)


# https://medium.com/@priyankads/common-regular-expressions-for-text-cleaning-in-python-5a13b832d340
# import re
# заменить ссылки в тексте своей строкой
# print(re.sub(r'http\S+', '###', text))
# print(re.sub(r'https?://[^,\s]+,?', '$$$', text))
# получить все ссылки из текста в виде списка строк
# print(re.findall(r'https?://[^,\s]+,?', text))
# удалить имейл из текста
# re.sub(r'([\w\.\-\_]+@[\w\.\-\_]+)', '', text)





