from __future__ import annotations
from pprint import pprint
from copy import deepcopy
from time import sleep

from pip._internal.cli.cmdoptions import python

# Интерактивное отображение работы питон
# https://pythontutor.com/

# интерактивное отображение алгоритмов
# https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

# рисовать диаграммы
# https://app.diagrams.net/

# Отменить действие в vscode:
# CTRL+Z
# Вернуть отменённое действие в vscode:
# CTRL+Y
# Импортировать модуль объекта на котором стоит курсор в vscode:
# CTRL+. затем ENTER

# Интерактивная консоль Python в vscode, типо IDLE
# CTRL+SHIFT+P
# Ввести: "repl"
# И выбрать: "Python: Запустить REPL"
# либо SHIFT+ENTER

# Типы данных

# Изменяемые (mutable)
# print(type(   {1, 1, "a"}    )) # -> set Множество
# print(type(  {'a':1, 2: 'b'} )) # -> dict Словарь
# print(type( [1, 1, 'a']      )) # -> list Список
# from array import array
# ?print(type(  array("l", [1, 1, 2])  ))      # -> array Массив
# ?print(type(  bytearray(3)  ), bytearray(3)) # -> Массив байт

# Неизменяемые (not mutable)
# print(type( 'abc'        )) # -> str Строка
# print(type(  (1, 1, 'a') )) # -> tuple Кортеж
# print(type(  None        )) # -> NoneType Отсутствие данных
# print(type(  True        )) # -> bool Логическое значение
# print(type(  1           )) # -> int Целое число
# print(type(  1.4         )) # -> float Число с плавающей точкой
# from decimal import Decimal
# print(type(Decimal('1.4'))) # -> decimal Точное число с плавающей точкой
# ?print(type(  1 + 1j       )) # -> complex Комплексное число
# ?print(type( frozenset([1, 1, 'a'])  )) # -> frozenset неизменяемое множество
# ?print(type(  bytes(3)  ), bytes(3))     # -> Байт


# класс Decimal служит для более точной работы с дробными числами чем встроенный тип float
# print(Decimal('1.4') * Decimal('0.1'), 1.4 * 0.1)

# print(complex(2, 3j)) # создание комплексного числа

# Узнать айди объекта
# print(id('строка'))
# print(id([1,2,3]))

# узнать адресс в памяти в шестнадцатеричном формате
# print(hex(id('строка')))
# print(hex(id([1, 2, 3])))

# print(license())

# ?запустить Pyton код прямо в консоли:
# python -c 'for i in range(5):print(i)'

# ?memoryview позволяет коду Пайтон получать доступ к внутренним данным обьекта,
# который поддерживает буферный протокол, без необзодимости копирования.
# Это позволяет программе использовать меньше памяти и увеличивает скорость выполнения.
# ba = bytearray('ABC', 'utf-8')
# mv = memoryview(ba)
# print('memoryview:', mv)
# print('байт под нулевым индексом:', mv[0])
# print('байт строка в unicode представлении:', bytes(mv[0:2]))
# print('список байт:', list(mv[0:2]))
# print(f'до изменения с помощью memoryview: {ba!r}')
# mv[1] = 90
# ?print(f'после изменения с помощью memoryview: {ba!r}')



# ?print("52 =", bytes(52)) # Преобразует объект в неизменяемую строку байтов
# print("Привет Мир! =", bytes('Привет Мир!', encoding='utf-8'))

# ?метод fromhex у класса bytes может преобразовывать шестнадцатиричную последовательность чисел в байт-строку
# b = bytes.fromhex('31 4B CE A9')
# print(b)
# b = b.decode('utf8')
# print(b) # один кило ОМ


# print("52 =", bin(52)) # преобразует десятичное число в двоичную (бинарную) строку с префиксом '0b'
# print("52 =", bin(52))[2:]

# print(bin(52), int(bin(52), 2)) # Возвращает двоичное представление целого числа.
# print(oct(52), int(oct(52), 8)) # Возвращает восьмеричное представление целого числа.
# print(hex(52), int(hex(52), 16)) # Возвращает шестнадцатеричное представление целого числа


# ?дизассемблировать(отобразить) байт-код скомпилированной функции на языке ассемблера.
# from dis import dis
# def func(a, b):
#     return a + b
# dis(func)


# Относительный импорт:
# from .filename import myfunc # импортировать функцию myfunc из файла filename который находится на одном уровне с файлом из котрого происходит импорт
# from ..filename import myfunc # импортировать функцию myfunc из файла filename который находится на уровень выше чем файл из котрого происходит импорт
# from ...filename import myfunc # импортировать функцию myfunc из файла filename который находится на два уровня выше чем файл из котрого происходит импорт
# и т.д.
# Абсолютный импорт:
# from foldername.filename import myfunc


# список изменяемый объект (id объекта всегда один и тот же)
# x = [1, 2, 3]
# print(id(x), x)
# x[2] = 6
# print(id(x), x)
# x.append(8)
# print(id(x), x)

# строка неизменяемый объект
# (но добавление нового элемента не меняет id в отличие от изменения существующего элемента)
# так работает в python <= 3.8, в python 3.11 например, id изменяется при любом раскладе
# y = '123'
# print(id(y), y)
# y = y[:2] + '6'
# print(id(y), y)
# y += '8'
# print(id(y), y)

# Области видимости (Пространства имен)
# built-in # встроенные функции в интерпретаторе, для их использования не надо импортировать модули, а так же операторы (зарезервированные слова).
# global   # объекты доступные в пространстве имён модуля.
# local    # объекты доступные внутри функции.
# nonlocal # делает доступной переменную в блоке внешней функции (обёртки).

# def a():
#     ''' документация функции "a" '''
# class b:
#     ''' документация класса "b" '''
#     def MY_METHOD_MY_METHOD_MY_METHOD_MY_METHOD_MY_METHOD():
#         pass
# print('Имя объекта:', a.__name__, b.__name__) # позволяет посмотреть имя объекта
# print('Документация объекта:', a.__doc__, b.__doc__) # позволяет посмотреть документацию объекта
# print(help(a)) # позволяет посмотреть документацию объекта
# print(globals()) # возвращает словарь с доступными объектами в пространстве имён текущего модуля

import math
#pprint(dir(math)) # позволяет узнать какие объекты содержаться в функции/модуле (без аргументов в текущем пространстве имён модуля)
#def func(): pass
# получить список атрибутов объекта
#pprint(dir(func))
#pprint(func.__dir__())

# ?print(__name__) # узнать какое состояние имеет переменная __name__ в текущем пространстве имён модуля

# ?pprint(__builtins__.__dict__)
# ?print(str.__dict__)
# ?print(vars(str))

# ?print(callable(len), callable('строка')) # проверяем является ли объект вызываемым

# ?print(locals()) # возвращает словарь с переменными и их значениями из текущей локальной области видимости в виде словаря
# ?print(vars()) # без аргумента работает как locals

# узнать инфу о функции
# def func(a: str, b: int) -> list:
#     c = 2; d = 'Hello, World!'
#     return c, d
# print(func.__code__.co_argcount)
# ?print(func.__code__.co_consts)
# ?print(func.__code__.co_varnames)

# ?Узнать родителей в иерархическом порядке у объекта
# class A: pass
# class B(A): pass
# print(B.mro())

# принадлежность объекта к конкретному классу можно проверить функцией isinstance
# 1арг. объект который мы хотим проверить, 2арг. класс (или кортеж классов) к которому они должны принадлежать, вернёт True/False
# print(isinstance('строка', int))
# print(isinstance('строка', str))
# # либо тоже самое с помощью класса type()
# print(type('строка') == int)
# print(type('строка') == str)

# принадлежность объекта к конкретному субклассу можно проверить функцией issubclass
# 1арг. тип к которому должен принадлежать объект который мы хотим проверить, 2арг. тип (или кортеж типов) проверяемых объектов, вернёт True/False
# print(issubclass(int, type(72)))
# print(issubclass(int, type("Hello World!")))
# print(issubclass(str, type("Hello World!")))

# class Obj: myattr = 7
# # получить атрибут у объекта
# print('getattr:', getattr(Obj, 'myattr')) # obj, name
# # установить атрибут для объекта
# setattr(Obj, 'myattr2', 'Hello World!') # obj, name, value
# # удалить атрибут у объекта
# delattr(Obj, 'myattr') # obj, name
# # проверить есть ли атрибут у объекта, возвращает True/False
# print('hasattr:', hasattr(Obj, 'myattr2')) # obj, name
# print('hasattr:', hasattr(Obj, 'myattr'))

# функция type определяет тип данных
# if type(True) == bool :
# #     print('bool')
# # if type(1) == int :
# #     print('int')

# Класс bool преобразует числовое значение в истину или ложь
# если число 0 значит ложь, остальные числа - истина
# print(bool(11))
# print(bool(-11))
# print(bool(0))
# так же работает и со строками, только в качестве лжи применяется пустая строка
# print(bool('a'))
# print(bool(''))
# так же и с коллекциями
# print(bool([1, 2]))
# print(bool([]))

# умножение разных типов данных
# print(1*5)
# print('1'*5) # строка
# print([[]]*5) # список
# print((1,)*5) # кортеж
# print(True*5, 1*5) # булевые
# print(False*5, 0*5)

# булевые значения можно суммировать если они суммируются в integer object
#         1     1      0      1     0
# array = [True, True, False, True, False]
# int_count = 0
# for bool_value in array:
#     int_count += bool_value
# print(int_count, sum(array))

# print(hash('string')) # хэш можно найти только у неизменяемых типов данных
# print(hash([1, 2, 3])) # TypeError: unhashable type: 'list'
# если в кортеже будет находиться изменяемый тип данных
# он перестаёт иметь хэш, функция выбросит исключение TypeError
# print(hash((1, 2, '3', '4')))
# print(hash((1, 2, [3, 4])))
# Если объекты равны то их хэш тоже равен
# Но равные хэши не гарантируют на 100% равенство объекта
# Если хэши не равны то объекты точно не равны
# print(hash((1, 2)), hash((1, 2)))
# print(hash('Hello World!'), hash('Hello World!'))

# код можно писать в одну строку с помощью точки с запятой ';'
# a = 1; b = 2; c = [1,2]
# print(a,b,c)

# по умолчанию print разделяет аргументы одиночными пробелами
# но при помощи параметра sep можно указать другой разделитель
# print('a', 'b', 'c', sep='111')

# параметр end может склеивать принты вместе
# print('a', 'b', 'c', end=' ')
# print('d', 'e', 'f')

# ?читабельный вывод словарей с табуляцией
# import json
# print(json.dumps(словарь, indent=4, ensure_ascii=False))

# перевод числового значения int или float в строку с помощью метода str()
# a = 5
# b = 5.7
# c = 'Строка с числом ' + str(a) + str(b)
# print(c)

# функция input запрашивает данные для ввода и передаёт их в строке
# функция int переводит строковые значения(цифровые) в целые числа
# функция float переводит строковые значения(цифровые) в числа с плавающей точкой
# a = input("Введите число:\n")
# b = int(a) + 5
# b = float(a) + 5
# print(b)

# a = float(input("Введите число: "))
# b = float(input("Введите число: "))
# print("Результат:", a + b)
# print("Результат:" + str(a + b)) # объединение строки с числом

# # eval() может выполнить лишь выражение Python
# print(eval("1024 + 1024"))
# print(eval("sum([8, 16, 32])"))
# print(eval("min([1, 2, 3])"))
# print(eval("[i for i in range(5)]"))
# x, y = 7, 7
# print(eval("x != y")) # в eval можно передавать глобальные переменные
# print(eval("x != y", {"x": 7})) # в eval можно указать только определенные переменные в формате словаря которые должны попасть в функцию.

# # compile() можно использовать для предоставления объектов кода для eval() вместо обычных строк.
# code = compile('5+4', '<string>', 'eval')
# print(eval(code))
# # exec() может выполнить любой фрагмент кода Python
# exec('if 1 > 0: print("da, 1 bolshe 0")')

# простейший калькулятор с использованием функции eval

# while True: print(eval(input()))

# while True:
#     text = input()
#     try:
#         result = eval(text)
#         print("\033[A                             \033[A")
#         print(text, '=', result)
#     except Exception as exc:
#         print(exc)


# print(1)
# print(2)
# print(3)
# ?for _ in range(3):
#     sleep(1)
#     print("\033[A                             \033[A") # удаляет одну строку в консоли

# Операторы условий
# if
# elif
# else
# :
# pass # оператор заглушка, допустим что бы не писать print() или кавычки документации ''' '''
# ... # так же работает как заглушка
# del <объект> # оператор удаления объекта
# del(<объект>) # тоже самое только с указанием объекта для удаления в круглых скобках

# Логические операторы (имеют приоритет выполнения)
# not # первый
# and # второй
# or  # третий

# continue # оператор для работы с циклами, пропускает итерацию и начинает следующую с самого начала
# break # оператор для работы с циклами, останавливает цикл и выходит из тела цикла
# else # оператор в том числе и для работы с циклами, сработает только в том случае
# если цикл завершиться сам по себе, то есть выполнит все итерации



# print(chr(i) for i in range(1, 4))
# ?for char in (chr(i) for i in range(1, 4)):
#     print(char)


# добавить более одного элемента за итерацию используя collection comprehension
# можно с помощью вложенных циклов и тернарного оператора
# lst = [1, 0, 2, 3, 0, 4]
# res = [i for N in lst for i in ([N] if N else ['hello', 'World'])]
# print(res)


# выражение присваивания/моржовый оператор
# присваиваем b значение a ** 2
# и проверяем если b > 0
a = 4

# if (b := a ** 2) > 0:
#     print(f'Kvadrat {a} eto {b}')

# # без использование скобок в b присвоится True
# if b := a ** 2 > 0:
#     print(f'Квадрат {a} это {b}')

name = 'Arseniy Astafev'
x = False
#
# if (name := name.split()[-1]) and not x:
#     print(name)
# print(name)

# # без использования скобок в name присвоится True
# if name := name.split()[-1] and not x:
#     print(name)
# print(name)


# на самом деле оператор del удаляет не сам объект а ссылку на объект
# и в качестве побочного результата сборщик мусора должен удалить объект
# если на него более никто не ссылается
# from sys import getrefcount
# from weakref import finalize
# a = {1, 2}
# ender = finalize(a, lambda : print('Garbage Collector eat {1, 2} object'))
# print('refcount:', getrefcount(a), ' object alive?', ender.alive)
# b = a # теперь на объект {1, 2} ссылаются переменные "a" и "b"
# print('refcount:', getrefcount(a), ' object alive?', ender.alive)
# c = b # теперь на объект {1, 2} ссылаются переменные "a", "b", "c"
# print('refcount:', getrefcount(a), ' object alive?', ender.alive)
# del a # теперь на объект {1, 2} ссылаются переменные "b", "c"
# print('refcount:', getrefcount(c), ' object alive?', ender.alive)
# del b # теперь на объект {1, 2} ссылается только переменная "c"
# print('refcount:', getrefcount(c), ' object alive?', ender.alive)
# c = 'Hello World!' # теперь на объект {1, 2} более никто не ссылается и сборщик мусора может удалить объект
# print('             object alive?', ender.alive)


# конструкция math case позволяет проверять первый аргумент последовательности
# и записывать последующие в переменные
# message = ['BEEPER', 440, 3]
# message = ['LED', 77, '214', '251', '192']
# # message = ['NECK', 440]
# # message = ['UNKNOWN', 'abcdef']
# match message:
#     case ['BEEPER', frequency, times]:
#         print(1)
#     case ['NECK', angle]:
#         print(2)
#     case ['LED', ident, intensity]:
#         print(3)
#     # можно указывать охранное условие if на ряду с case
#     case ['LED', ident, red, green, blue] if int(green) < 255:
#         print(4)
#     case _:
#         print(5)

# phone = '162367721261'
# phone = '262367721261'
# phone = '362367721261'
# phone = '462367721261'
# match tuple(phone): # превращаем строку в коллекцию символов
#     case ['1', *rest]: # проверяем первый символ остальные помещаем в переменную rest
#         print(1)
#     case ['2', *rest]:
#         print(2)
#     case ['3' | '4', *rest]:
#         print(3,4)

# location = ['Shanghai', 'CN', 24.9, (31.1, 121.3)]
# match location:
#     # для переменных можно указывать алиасы
#     case [name as title, _, _, (lat, lon) as coord]:
#         print(title, coord)

# i = 0
# print('>>> IN')
# while i < 10:
#     i += 1
#     if i > 3 and not i > 6: # если i больше 3 и i не больше 6 тогда пропускаем итерацию
#         print('i =', i, 'continue')
#         continue
#     print('i =', i)
#     if i == 8:
#         print('i =', i, 'break')
#         break
# else:
#     print('сработал оператор else')
# print('>>> OUT')

# вместо двух указателей идущих на встречу друг другу можно использовать цикл
# N = 10
# for i in range(N):
#     print(i, N-i-1)

# Убираем повторяюзиеся элементы из списка с помощью цикла
# a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
# b = []
# for i in a:
#     if i not in b:
#         b.append(i)
# print(a)
# print(b)

# сортировка строки по маленьким и большим буквам и не буквенным символам с помощью цикла
# s = 'h@lLo WOrld!'
# for i in s:
#     if i >= 'a' and i <= 'z':
#         print(i, 'small')
#     elif 'A' <= i <= 'Z':
#         print(i, 'big')
#     else:
#         print(i, 'не буквенный символ')

# подсчет кол-ва повторяющихся букв в строке с помощью циклов
# s = 'abczjhdf HG jgkfYGg jhgkdf 543 *(^($&*#'
# letters = [0] * 26
# print(ord('a'))
# for i in s.lower():
#     if i >= 'a' and i <= 'z':
#         number = ord(i) - 97
#         letters[number] += 1
# for i in range(26):
#     if letters[i] > 0:
#         print(chr(i + 97), letters[i])

# Операторы сравнений (Проверяют объекты на равенство их значений)
# ==
# <
# >
# <=
# >=
# !=

# построение диапазона с помощью операторов сравнений
# number = 4
# if 3 <= number <= 6:
# # if number >= 3 and number <= 6: # аналогичная запись
#     print('число в диапазоне от 3 до 6')

# операторы сравнения можно записывать в цепочке
# a, b, c, d = 1, 1, 1, 1
# if a == b == c == d:
#     print('все числа равны')

# оператор 'in' если часть объекта равна возвращает логическое значение True иначе False
# link1 = 'https://'
# link2 = 'https://#'
# link3 = 'https://www.youtube.com'
# print(link1 in link3) # True
# print(link2 in link3) # False

# оператор 'is' если объекты ссылаются на одну и туже ячейку в памяти то возвращает логическое значение True иначе False
# x = 'hi'
# y = 'hi'
# print(x is y) # True

# для слишком больших чисел выделяется отдельная область в памяти
# x = 31**25
# y = 31**25
# print(x, y, x is y) # True
# x = 31**26
# y = 31**26
# print(x, y, x is y) # False

# x = 32**21
# y = 32**21
# print(x, y, x is y) # True
# x = 32**25
# y = 32**25
# print(x, y, x is y) # False

# x = 25**25
# y = 25**25
# print(x, y, x is y) # True
# x = 26**26
# y = 26**26
# print(x, y, x is y) # False

# для списков выделяется отдельная область в памяти
# x = [1, 2, 3]
# y = x
# z = [1, 2, 3]
# print(x is y) # True
# print(y is z) # False
# print(x is z) # False

# float('inf') считается самым большим числом в python, он действует как неограниченное верхнее значение для сравнения
# print(float('inf') > 99999**99999) # True
# float('-inf') #считается самым малым числом в python.
# print(float('-inf') < -9999999999) # True
# from math import inf
# print(inf == float('inf'))

# создать и проверить объект на NaN
# from math import isnan
# nan = float('nan')
# print(isnan(nan)) # True
# print(isnan(1.7)) # False

# Математические операторы (имеют приоритет выполнения)
# a = 10 + 5
# a = 10 - 5
# a = 10 * 5
# a = 19 / 5 # обычное деление, ответ = 3.8
# a = 19 // 5 # деление с отбросом остатка после точки (в числе 19 число 5 помещается 3 раза)

# Остаток от деления 19 % 7 в число 19 число семь помещается 2 раза, остаток = 5

# Так же можно находить числа кратные числу, например найти числа кратные 4 в последовательности чисел
# for n in range(21):
#     if n % 4 == 0:
#         print(n)

# a = число % 2 # узнаём есть ли остаток после точки при делении
# возвращает 0 если остатка нет, 1 если остаток есть (можно вычислять четные или не четные числа)

# for n in range(1, 11):
#     if n % 2 == 0:
#         stri = 'Четное'
#     else:
#         stri = 'Не четное'
#     print(f'Число: {n} {stri}')

# a = 6 ** 3 # возведение в степень (аналог 6*6*6)
# унарный минус
# a = 10
# a = -a # из положительного в отрицательное значение
# a = -a # из отрицательного в положительное значение
# print(a)

# Операции с числами
# print(sum( [10, 7, 2, 15] )) # функция sum() складывает все числовые значения из списка
# print(abs(-13.2)) # функция abs() переводит число из отрицательного в положительное
# print(min(16,9,-3,42,25)) # возвращает минимальное число
# print(max(90,4,-2,54,63)) # возвращает максимальное число
# print(pow(16, 7), 16**7) # функция pow() возводит число в степень
# округление числа с плавающей точкой
# print(round(5.758, 1)) # округление от середины # так же может иметь 2 арг. который будет указывать с какой точки начинать округлять
# import math
# print(math.ceil(5.7)) # округление всегда в большую сторону
# print(math.floor(5.7)) # округление всегда в меньшую сторону
# print(math.trunc(54.748)) # обрезает знаки после точки оставляя только целое число # точно так же работает int(54.748)
# print("pi =", math.pi) # число пи

# print(
#     divmod(5, 5),
#     (5//5, 5%5),
#     (math.floor(5/5), 5%5),
# )
# lst = [1, 3, 5, 7, 9]
# print([divmod(x, 2) for x in lst])
# [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1)]

# для разделения математических операций по приоритету используются круглые скобки
# приоритет на примере
# # 7   5   6   4   3     2     1
# y = x + 7 > x + 2 * (x ** (3 ** x) )

# Арифметическая прогрессия
# a = int(input()) # 1  # 100
# b = int(input()) # 1  # 50
# c = int(input()) # 10 # 1
# x = a + b * (c - 1)
# print(x)

# Геометрическая прогрессия
# a = int(input()) # 1 # -2
# b = int(input()) # 2 # 10
# c = int(input()) # 5 # 3
# x = a * b ** (c - 1)
# print(x)

# разделение числа посимвольно с помощью математических операторов, замена срезам/индексации строк
# a = 1234
# n1 = a // 1000 # для первой цифры можно не использовать остаток от деления
# n2 = a // 100 % 10
# n3 = a // 10 % 10
# n4 = a // 1 % 10
# print(n1, n2, n3, n4, sep='   ')

# операции присваивания в пайтон
# a += b прибавляем a к b (аналог a = a + b)
# a -= b (аналог a = a - b)
# a *= b (аналог a = a * b)
# a /= b (аналог a = a / b)
# a //= b (аналог a = a // b)
# a %= b (аналог a = a % b)
# a &= b (аналог a = a & b)
# a |= b (аналог a = a | b)

# программа открывающая сайт https://www.youtube.com
# input не пропускает цикл пока пользователь не введёт какие либо данные
# import os
# while True :
# 	sayt = input("Введите адрес сайта:\n")
# 	if sayt == "завершить" :
# 		break
# 	if "https://" in sayt :
# 		os.system("start " + sayt)
# 		print("if")
# 	elif "www." in sayt :
# 		sayt = "https://" + sayt
# 		os.system("start " + sayt)
# 		print("elif")
# 	else :
# 		sayt = "https://www." + sayt
# 		os.system("start " + sayt)
# 		print("else")

# import time
# import os
# time.sleep(3)
# os.system("start https://www.youtube.com")
# time.sleep(3)
# os.system("start https://www.twitch.tv")
# time.sleep(3)
# os.startfile("C:\Program Files\CPUID\CPU-Z\cpuz.exe")

# полностью очистить терминал
# import os
# os.system('cls') # для windows
# os.system('clear') # для linux/mac

# модуль рандом
# import random
# print(random.randint(0, 0xFFFFFF))
# print(random.randint(0, 100)) # выбрать рандомный элемент из диапазона
# print(random.randrange(1, 100)) # выбрать рандомный элемент из range
# # выбрать рандомный элемент из коллекции
# print(random.choice(['Lorem', 'ipsum', 'dolor', 'sit', 'amet,', 'consectetur', 'adipiscing', 'elit']))
# lst = list(range(1, 10))
# print(lst)
# random.shuffle(lst) # перемешать элементы в коллекции
# print(lst)

# while оператор цикла исполняется (пока условие верно)
# цикл от 1 до 5
# можно подключить оператор else который сработает по завершению цикла
# a = 0
# while a < 5 :
# 	a += 1
# 	print(a)
# else :
# 	print("finish")

# while True :
# 	a = int(input())
# 	b = 1
# 	count = 0
# 	while count < a :
# 		count += 1
# 		b *= count
# 	else :
# 		print("result:", b)

# while True :
# 	a = ""
# 	while len(a) < 5 :
# 		b = input("Ввод данных: ")
# 		if b == "o" :
# 			continue # игнорируем символ
# 		if b == "t" :
# 			break # прерываем цикл
# 		a += b
# 	else :
# 		print("result:", a)
# 	print(">>> Сброс программы <<<")


# def _len(x):
#     print(_len.__name__, x)
#     return len(x)

# # в условии цикла while не стоит использовать вызываемые объекты т.к. они будут выполнены на каждой итерации
# L = [1, 2, 3]
# while _len(L) < 5:
#     pass


# цикл for

# basket = [1,2,3,4,5,6]
# # спискам в цикле можно применять метод среза тем самым укоротив цикл до 3 итераций
# for i in basket[:3]:
#     print(i)

# можно подключить оператор else который сработает по завершению цикла
# ищем конкретные символы
# a = "test text"
# count = 0
# for i in a :
# 	if i == "t" :
# 		print("найдено совпадение:", i)
# 		count += 1
# 	if i == "x" :
# 		break
# else :
# 	print("result:", i, "=", count)

# пропускаем символы
# a = "test text"
# count = 0
# for i in a :
# 	if i == "t" :
# 		continue
# 	print(i)
# else :
# 	print("result:", i, "=", count)

# подсчёт количества повторяющихся символов
# while True :
# 	a = "йцукенгшщзхъфывапролджэячсмитьбю0123456789"
# 	b = input("Введите строку:\n")
# 	for i in a :
# 		count = 0
# 		for index in b :
# 			if i == index :
# 				count += 1
# 		if count > 0 :
# 			# idk :D
# 			if count == 2 or count == 3 or count == 4 or count == 22 or count == 23 or count == 24 :
# 				name = "раза"
# 			else :
# 				name = "раз"
# 			print("буква", '"' + i + '"', "попалась", count, name)

# функция range принимает аргументы (start, end, step)
# for i in range(3, 16, 2) :
# 	print(i)

# for i in range(10, -1, -1): # обратная последовательность от 10 до 0
#     print(i)
# либо так
# for i in range(11)[::-1]:
#     print(i)

# for i in range(-10, 0): # отрицательная последовательность от -10 до -1
#     print(i)

# a = range(10001)
# b = list(range(10001))
# # к range можно применять срезы, обращаться по индексу.
# print(a[4], a[10:16], list(a[10:16]))
# # объект range не хранит всю последовательность в памяти как генератор.
# print('размер range:', a.__sizeof__())
# print('размер list:', b.__sizeof__())


# итерация элементов в итерируемом объекте с помощью функций iter, next
# r = range(4)
# # print(r, type(r)) # range(0, 4) <class 'range'>
# # r = [0, 1, 2, 3]
# # print(r, type(r)) # [0, 1, 2, 3] <class 'list'>

# it = iter(r)
# # it = r.__iter__() # тоже самое просто другой синтаксис
# # print(it, type(it)) # <range_iterator object at 0x0000027F539A9810> <class 'range_iterator'>

# n1 = next(it)
# n2 = next(it)
# n3 = next(it)
# n4 = it.__next__() # тоже самое просто другой синтаксис

# print(n1, n2, n3, n4)
# Если элементы закончатся и ещё раз вызвать next то сработает исключение StopIteration

# т.к. класс map возвращает итератор он может вернуть одно значение только один раз
# поэтому при поиске значения с помощью оператора in в итераторе,
# под капотом происходит последовательный перебор всех элементов итератора,
# поэтому найти значения которые находятся раньше элемента на котором был остановлен перебор уже не получиться.
# iterator = map(abs, [1, 2, 3, 4, 5])
# print(2 in iterator)  # True
# print(4 in iterator)  # True
# print(2 in iterator)  # False
# print(3 in iterator)  # False
# print(list(iterator)) # []


# a = [5, 6, 7]
# b = [100, 200, 300, 400]
# # объект итератор zip упаковывает в кортеж значения стоящие на одинаковых индексах в двух и более списках
# zp = zip(a, b)
# print('zip:', zp, list(zp))

# # тоже самое только с помощью цикла
# lst = []
# for i in range(min(len(a), len(b))):
#     lst.append((a[i], b[i]))
# print('lst:', lst)

#########################################################################################
# Список (list) упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#########################################################################################

# индексация с конца            -4              -3                -2               -1
# индексация с начала            0               1                 2                3
# xxxxxxxxxxxxxxxxxxxxx = ['Выпить кофе', 'Изучить Python', 'Захватить мир', 'Купить хлеба']

# узнать длинну списка можно с помощью функции len(имя списка)
# в питон есть обратная индексация с конца к началу с помощью знака - вместо нуля идёт -1 и т.д.
# a = [4, 2, 33, "строка", 5, ["a", "b", 16] ]
# print(a[0])
# без исключения обратится к последнему элементу списка (если он пустой):
# lst = []
# a = lst[-1:] or None
# print(a)
# можно обращатся к вложенным спискам внутри списка таким способом
# print(a[-1][1])
# можно перезаписывать определённую ячейку из списка
# a[0] = 7
# print(a[0])
# можно менять данные в списке или списках местами множественным присваиванием # https://younglinux.info/python/task/exchange
# a[0], a[2] = a[2], a[0]
# print(a[0], a[2])
# можно добавить данные в список
# a = a + [7]
# print(a)
# функция list() разбивает строку по 1 символу и превращает её в список
# a = list("5861cfg")
# print(a)

# сравнение списков (при этом происходит поочередное сравнение каждого элемента списка слева на право)
# print('[1] <= [1]', [1] <= [1])
# print('[2] <= [1]', [2] <= [1])
# print('[1, 1] <= [1, 1]', [1, 1] <= [1, 1])
# print('[1, 2] <= [1, 1]', [1, 2] <= [1, 1])

# с помощью fromkeys можно исключить дубликаты из последовательности,
# сохранив при этом порядок элементов в отличие от set()
# lst = ['spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs']
# tpl = ('spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs')
# print(list(dict.fromkeys(lst).keys()))
# print(list(dict.fromkeys(tpl).keys()))
# print(list(set(lst)))

# Пару вариантов получения одного из двух ключей в словаре если он существует иначе None
# key = ([k for k in kwargs if k in ("id__in", "pk__in")] or (None,))[0]
# key = ("id__in" if "id__in" in kwargs else None) or ("pk__in" if "pk__in" in kwargs else None)

########################################
# Методы для работы со списками (list) #
########################################

# x = [9, 8, 7, 6, 5]
# print(7 in x[1:3]) # с помощью среза проверяем есть ли данный элемент в списке в промежутке от 1 до 3 индекса
# print(len(x)) # узнать длинну списка
# x.append("kek") # добавляет элемент в конец списка
# x.insert(1, 7) # добавляет элемент перед указанным индексом
# print(x.count(7)) # узнаём сколько одинаковых элементов в списке по имени элемента
# print(x.index(7)) # узнаём индекс элемента в списке по имени элемента (2арг. с какого индекса начинать искать, 3арг. на каком закончить искать)
# x.sort() # сортирует список по возрастанию, если добавить арг. reverse=True список отсортируется по убыванию
# так же у способов sort и sorted имеется второй именованный арг. key=функция для изменения принципа сортировки
# примечание, sort и sorted сортирует как цифры так и каждый символ в строке включая буквы
# c = sorted(x, key=abs) # возвращает новый отсортированный список в формате списка в переменную (родительский не трогает)
# x.reverse() # инвертирует список и перезаписывает его в эту же ячейку памяти (способ без метода x[:] = x[::-1])
# print(reversed('98765')) # создаёт итератор с инвертированными элементами
# (аналогично x = list('98765') x.reverse() print(x))
# x.pop(0) # удаляет элемент по указанному индексу (если указать переменную то сохранит удалённый элемент в переменную)
# по умолчанию без аргумента pop() удаляет элемент в конце списка, является аналогом del список[-1]
# x.remove(7) # удаляет конкретный элемент в списке по имени элемента
# x.clear() # полностью очищает список
# x.extend(["asd", "gg", 123]) # распаковывает список в конце списка
# c = x.copy() # создаёт копию списка в переменную (аналоги c = x[:] или c = list(x))
# c = ["Hello"]+["Random"]+["Friend"] # списки можно складывать
# print(c)
# print(x)
# new_text = '___'.join(c) # переводим список обратно в строку в качестве пробелов можно указать любой символ
# print(new_text)

# a = list(range(10))
# b = []
# for i in a:
#     if i == 5 or i == 6:
#         continue
#     # b += [i]
#     b.append(i) # аналогично
# else:
#     print(b)

# в списках можно использовать синтаксис срезов так же как и в строках

# a = list(range(1, 21))
# b = []
# если нам нужно поверхностно скопировать список то используем метод copy()
# c = a.copy()
# либо можно поверхностно скопировать таким способом
# g = list(a)
# print(id(a), id(g))
# либо поверхностное копирование с помощью синтаксиса срезов [start:stop:step]
# c = a[::] # полный список
# c = a[0::2] # заменяем цикл одной строчкой
# c = a[1::2] # заменяем цикл одной строчкой
# c = a[:5]
# c[:2] = ['gg', 'wp'] # заменяем первые 2 элемента на элементы из нового списка
# c[:2] = [] # удаляем первые 2 элемента т.к. заменяем их пустотой, если написать c[:] можно очистить весь список
# так же можно заменять значение по конкретному индексу c[3] = 6
# print(c)

# del c[2] # удалить значение по индексу

# for i in a:
#     if i % 2 == 0:
#         a.remove(i) # из списка a удаляем числа кратные 2 то есть получаем нечетные
#         b.append(i) # в список b записываем только числа кратные 2 то есть четные
# else:
#     print("a:", a)
#     print("b:", b)
#     print("c:", c)

#######################################################################################################
# Кортеж (tuple) неизменяемая упорядоченная коллекция элементов (присутствуют повторяющиеся значения) #
#######################################################################################################

# x = 1, # создание кортежа без помощи круглых скобок с одним значением и запятой
# print(x)

# x = (9, 8, 7, 6, 5, 4) # создание кортежа, скобки при создании дают наглядное представление что это кортеж
# a, b, c, d, e, f = x # присвоение каждого значения по очереди из кортежа в переменные
# print(a, b, c)

# x = () # создание пустого кортежа при помощи скобок

# x = tuple() # создание пустого кортежа классом tuple
# print(x)

# для заполнения tuple можно использовать любую итерабельную последовательность
# print(tuple([1, 2, 3]), tuple({1, 2, 3}), tuple((1, 2, 3)), tuple('123'))

# кортеж имеет индексацию по аналогии со списками
# print(x[0], x[4])

# хоть кортеж и является не изменным, но если в нём содержится изменяемый тип данных мы может изменить только его
# y = (1, 2, 3, [1, 2], 4)
# y[3].append(7)
# y[3].append(14)
# print(y)

# кортеж можно использовать в качестве ключа для словаря
# a = (1, 2, 3)
# b= {}
# b[a] = 'hello'
# print(b)

# у кортежа очень мало методов, поэтому для его изменения сначало надо
# преобразовать в список, изменить, затем преобразовать обратно в кортеж
# tupl = (9, 8, 7, 6, 5, 4)
# lis = list(tupl)
# lis[0] = 42
# lis.append(31)
# tupl2 = tuple(lis)
# print(tupl2)

# my_tuple = ('python', 'is', 'awesome', 'is')
# print(my_tuple[2]) # обращение к элементу кортежа по индексу
# к кортежам можно применять срез
# print(my_tuple[1:2])

# print(my_tuple + my_tuple) # кортежи можно складывать
# print(my_tuple * 2) # кортежи можно дублировать
# print('is' in my_tuple, 'abcde' in my_tuple) # с помощью in можно проверять находится ли конкретный элемент в кортеже

# при использовании оператора присваивания для изменения изменяемой коллекции
# внутри неизменяемого кортежа возбуждается исключение но при этом значение коллекции изменяется.
# t = (1, 2, [30, 40])
# try:
#     t[2] += [50, 60]
# except TypeError as exc:
#     print(exc)
#     print(t)
# # при использовании метода extend никакого исключения не возбуждается
# g = (1, 2, [30, 40])
# g[2].extend([50, 60])
# print(g)

# функция enumerate превращает каждый элемент списка в кортежи состоящие из индекса и значения
# можем принимать 2арг. в котором указывается с какого индекса начинать отсчёт
# print(list(enumerate([10, 20, 30, 'abcd', '77'], 765)))
# lst = [10, 20, 30, 'abcd', '77']
# strg = 'abcd'
# tpl = (10, 20, 'one', 'two')
# st = {10, 20, 'aa', 'bb'}
# dct = {10:'10', 20:'20', 30:30, 'ade':'eda'}
# for index, value in enumerate(dct):
#     print(index, value)

#########################################
# Методы для работы с кортежами (tuple) #
#########################################

# print(len(my_tuple)) # узнать количество всех элементов в кортеже
# print(my_tuple.count('is')) # узнаём количество элементов по значению
# print(my_tuple.index('is')) # возвращает первый попавшийся индекс искомого элемента (слева на право)
# print(sorted(my_tuple)) # возвращает новый отсортированный список в переменную (родительский не трогает)

################################### Блок Кортежа закончен ###################################

# парсинг файлов
# ('C:\\pyTraining\TestFolder', ['Новая папка (1)', 'Новая папка (2)'], ['Новый текстовый документ 1.txt', 'Новый текстовый документ 2.txt', 'Новый точечный рисунок 1.bmp'])
# import os
# import time
# list = []
# for adress, dirs, files in os.walk("C:\\pyTraining\TestFolder"):
#     # list.append(adress) # пути ко всем папкам
#     for file in files:
#         full = os.path.join(adress, file)
#         # if ".txt" in full:
#         # if time.time() - os.path.getctime(full) < 86400:
#             # list.append(full)
#         # путь ко всем файлам
#         list.append(os.path.join(adress, file))
#     print(list)

#####################
# Работа с классами #
#####################

# class Class:
#     pass
# cls = Class()

# # получить класс у экземпляра можно следующими способами
# print(cls.__class__)
# print(type(cls))

######################
# Работа с функциями #
######################

# def turtle():
#     return 'eggs'

# print(turtle.__class__) # функции являются классами
# pprint(turtle.__class__.__dict__) # которые содержат атрибуты и методы

# print(turtle())
# print(turtle.__call__())
# print(turtle.__call__.__call__())
# print(turtle.__call__.__call__.__call__())

# Функции являются разделяемым объектом который можно использовать
# одновременно в нескольких контекстах равно как экземпляры одного и того же класса.

# def f(): return [1]
# onevar1 = f()
# [onevar2] = f() # с помощью указания списка или кортежа можно автоматически распаковать вернувшийся список
# (onevar3,) = f()
# print(onevar1, onevar2, onevar3)

# функция определения калорийности
# def calorie_calculator(name, get_calorie, spend_calorie):
#     if get_calorie > spend_calorie:
#         msg = name + ' getting fat'
#     else:
#         msg = name + ' lose weight'
#     return msg
# print(calorie_calculator('Arseniy', 2000, 2150))
# person = ['Ivan', 1900, 1200]
# # в функцию можно передавать сразу список с помощью спец символа * перед названием списка
# print(calorie_calculator(*person))

# оператор return возвращает значение в точку запуска функции то есть show2()
# def show2():
#     x = 7 + z
#     return x
# z = 4 # переменная должна быть выше точки запуска функции остальное не важно
# y = show2()
# print(y) # взаимодейстовать с переменной x внутри функции можно только через return
# x = show2() + 1
# print(x)
# z = 6
# t = show2()
# print(t)

# можно записывать дефолтные аргументы и задавать им значение
# def count_list(list, boolean = False, count = 0):
#     if boolean == True:
#         typelist = type(list[5]) # узнём тип элемента списка
#         for i in list:
#             count += 1 # узнём сколько элементов в списке
#         return count, typelist

#     else:
#         for i in list:
#             count += 1
#         return count

# j = [9, 8, 7, 6, "a", 0.4, True]

# передали 2 аргумента вернулось 2 аргумента
# h, p = count_list(j, True)
# print(h, p)

# передали 1 аргумент вернулся 1 аргумент
# h = count_list(j)
# print(h)

# Если требуется распаковать больше значений чем указано переменных,
# остальные значения попадут в переменную список со звёздочкой *
# *x2, y2, z2 = 0, 1
# print(x2, y2, z2)
# x1, *y1, z1 = 0, 1
# print(x1, y1, z1)
# x3, y3, *z3 = 0, 1
# print(x3, y3, z3)
# a, b, *c = 0, 1, 2, 3, 4
# print(a, b, c)

# если перед аргументом записать * то все аргументы прописанные после него превратятся в кортеж
# можно записать аргументы после кортежа если указать в вызове имя аргумента вместе со значением
# def name(h, d, *args, key1, key2):
#     print(h)
#     print(d)
#     print(args)
#     print(key1)
#     print(key2)
# name(1, 2, 3, 4, 5, key1=6, key2=7)

# функция возвращает по одному элементу без повторений
# def exclusive_item(*args, key=False):
#     newlist = []
#     for i in args:
#         for y in i:
#             if y not in newlist:
#                 newlist.append(y)
#     if key:
#         newlist.sort()
#     return newlist


# # args = arguments
# def print_ab(a, b, *args):
#     print(a)
#     print(b)
#     print(args)
# # Передача списка с помощью спец символа * разбивает его поэлементно и отправляет каждый
# # элемент в виде отдельного аргумента. (аналог передачи по индексу lst[0], lst[1] и т.д.)
# lst = [10, 20, 30, 40]
# print_ab(*lst)
# # Если не угадать с количеством передаваемых элементов и объявленых аргументов в функции
# # то получим исключение TypeError, что бы не прописывать каждый аргумент в функции, можно
# # воспользоваться спец символом * уже в функции для включения всех полученных элементов в один кортеж


# # kwargs = keyword arguments
# # если между позиционными a, b и запакованными **kwargs стоит "/"
# # то аргументы из **kwargs автоматически не смогут перейти в a, b
# # тем самым будет вызвана ошибка TypeError

# # все аргументы слева от "/" чисто позиционные, то есть при вызове функции их не надо указывать явно,
# # после "/" можно задавать как неименованные так и именованные аргументы.

# def print_ab2(a, b, /, **kwargs): # нельзя передавать именованные a=1, b=2
# # def print_ab2(a, b, **kwargs): # можно передавать именованные a=1, b=2
#     print('a:', a)
#     print('b:', b)
#     print('kwargs:', kwargs)
# # Таким же способом *dct можно передать ключи словаря, а с помощью двух **dct значения словаря
# # в случае с **dct необходимо явно описывать принимаемые аргументы в функции либо использовать **kwargs
# dct = {'c':10, 'd':20, 'e':30, 'f':40}
# print_ab2(1, 2, **dct)
# print()
# print_ab2(1, 2, c=10, d=20)


# z = [9,8,7]
# x = [8,8,9,7,6,5]
# c = [1,2,3,4,5,6,7,7]

# t = exclusive_item(z, x, c, key=True)
# print(t)

# x = 5
# def name():
#     global x # пезаписываем глобальную переменную вне функции
#     x += 10
#     print(x)
# name()
# print(x)

# x = 5
# def name():
#     x = 10
#     def name2():
#         nonlocal x
#         # nonlocal x # аналог global но использовать можно только во вложенной функции
#         x = 100
#         print(x)
#     name2()
#     print(x)
# name()
# print(x)

# используя 2 global можно прокинуть переменную из вложенной функции в глобальную область видимости файла
# x = 5
# def name():
#     global x
#     x = 10
#     def name2():
#         global x
#         x = 100
#         print(x)
#     name2()
#     print(x)
# name()
# print(x)

# Вычисляем объем цилиндра
# import math
# # константы правильно записывать в верхнем регистре
# PI = math.pi

# def radius():
#     n = float(input("Введите диаметр цилиндра в см: "))
#     n /= 2
#     return n

# def height():
#     m = float(input("Введите высоту цилиндра в см: "))
#     return m

# def volume():
#     r = radius()
#     h = height()
#     s = PI * r ** 2
#     v = s * h
#     return v
# print("Объем цилиндра:", volume(), "см3")

# def massa(g):
#     n = float(input("Удельный вес г/см3: "))
#     return g * n / 1000
# print("Вес цилиндра в кг:", massa(volume()))

#############################################################################################
# Словарь (dict) изменяемая упорядоченная(в python) коллекция элементов с доступом по ключу #
# иногда ещё называют ассоциативным списком или хеш-таблицей.                               #
# в словаре данные всегда привязаны к ключу                                                 #
#                                                                                           #
# ключём в словаре могут быть только неизменяемые типы данных,                              #
# если в кортеже содержится изменяемый тип данных то кортеж не может быть ключём.           #
#############################################################################################

# d = {}
# tpl = ((1, 2, (1, 2, [1, 2])), 1, 2)
# # для ключа словаря можно использовать только полностью не изменяемые типы данных
# # даже глубоко вложенный изменяемый тип данных - список - вызовет ошибку: TypeError: unhashable type: 'list'
# d[tpl] = 'test'

# dict1 = {}
# not_mutalbe_tuple = (4, True)
# dict1[not_mutalbe_tuple] = 'текст'
# print(dict1)
# mutable_tuple = (4, [1, 2])
# dict1[mutable_tuple] = 'текст' # TypeError: unhashable type: 'list'

# d1 = {} # создаём пустой словарь
# d1 = dict() # способ с помощью функции

# d2 = {'name':'Arseniy', 'lang':'ru'}
# d3 = dict(name='Arseniy', lang='ru')
# print(d2, d3)

# d1 = {'a':7}
# print(d1['a']) # вызов по ключу, ключ 'a' значение 7
# d1['b'] = 9 # добавление пары ключ:значение в конец словаря (если такого ключа ещё не сущестует)
# d1['a'] = 4 # изменение значения по ключу (если такой ключ уже существует)
# del d1['b'] # удаление элемента по ключу
# print(d1)

# print(dict(raz=7, dva=9)) # создание словаря с парой ключ:значение

# конструктор класса dict может принимать итераторы с коллекциями из 2 элементов
# и просто коллекции из 2 элементов для создания словаря
# lst1 = ['a', 'b', 'c']
# lst2 = [1, 2, 3]
# print(dict(zip(lst1, lst2)))
# print(dict([('a', 1), ('b', 2), ('c', 3)]))
# print(dict([['a', 1], ['b', 2], ['c', 3]]))


# Генерируем новый словарь на базе старого
# old_dict = {'Hello': 1, 'World': 2}
# print({ '__' + key: val for key, val in old_dict.items() })
# print({ val: key for key, val in old_dict.items() })

# new_dict = {}
# for key in old_dict:
#     new_dict[old_dict[key]] = key
# print(old_dict, new_dict)

# Заменяем ключ в словаре (с помощью удаления старого и создания нового)
# old_dict = {'Hello': 1, 'World': 2}
# print(old_dict, id(old_dict))
# for old_key, old_val in list(old_dict.items()):
#     del old_dict[old_key]
#     old_dict[old_val] = old_key
# print(old_dict, id(old_dict))


# реверс ключей вместе со значениями в словаре
# d = {'a': 1, 'b': 2, 'c': 3}
# print(d)
# d = dict(
#     tuple(
#         zip(
#             reversed(d.keys()),
#             reversed(d.values())
#         )
#     )
# )
# print(d)


# при сравнении словарей сравниваются как ключи так и их значения
# d1 = {'a':4, 'b':4}
# d2 = {'a':4, 'b':4}
# d3 = {'a':4, 'b':3}
# print(d1 == d2, d1 == d3)

# сравнить только ключи
# print(d1.keys() == d2.keys(), d1.keys() == d3.keys())


# d1 = {'a': 1, 'b': 2}
# d2 = {'g': 9, 'b': 4}
# mySet = {'g', 'b'}

# (исключаются дубликаты за счёт преобразования в set)

# объединение словарей
# d3 = d1 | d2
# print(d1, d2, d3)
# d1 |= d2
# print(d1, d2)

# пересечение ключей словарей
# d3 = d1.keys() & d2.keys() # {'b'}
# print(d1, d2, d3)

# разность ключей из первого словаря
# d3 = d1.keys() - d2.keys() # {'a'}
# print(d1, d2, d3)

# разность ключей из двух словарей
# d3 = d1.keys() ^ d2.keys() # {'g', 'a'}
# print(d1, d2, d3)

# все эти операции можно производить между ключами словаря и сетом
# print(d1.keys() | mySet) # {'g', 'a', 'b'}
# print(d1.keys() & mySet) # {'b'}
# print(d1.keys() - mySet) # {'a'}
# print(d1.keys() ^ mySet) # {'g', 'a'}
# так же эти операции можно производить и между .items()
# но только в том случае если все значения в словарях являются неизменяемыми

#########################################
# Методы для работы со словарями (dict) #
#########################################

# https://stackoverflow.com/questions/18552001/accessing-dict-keys-element-by-index-in-python3

# d1 = {1:'one', 2:'two', 3:'three', 4:'four'}

# print(dict.fromkeys([1, 2, 3, 4, 5], 'значение')) # задаём одно значение для ряда ключей
# d1.clear() # удаляет всё из словаря

# print(d1.get('ключ')) # тоже самое что вызов по ключу через квадратные скобки, но если не будет значения вернёт None
# print(d1.get('ключ', 'своё значение')) # Можно изменить None на своё значение

# Возвращает значение выбранного ключа, если такого ключа нету создаёт ключ со значением None и так же возвращает None.
# Если указать через запятую своё значение то оно запишеться вместо None и оно же вернётся
# print(d1.setdefault("имя ключа", "имя значения"))
# print(d1)

# print(d1.pop(3)) # удаляет пару ключ:значение и возвращает значение удалённой пары, является аналогом del словарь[ключ], если пары нету raise KeyError но можно указать дефолтное значение вторым аргументом
# print(d1.popitem()) # удаляет последнюю пару из словаря и возвращает её в виде кортежа (ключ, значение)

# print(d1.items()) # возвращает список с кортежами ключ:значение (нужен для работы с циклом for)
# print(d1.keys()) # возвращает ключи в виде списка (нужен для работы с циклом for) может использоваться как множество, т.к. ключи уникальны
# print(d1.values()) # возващает значения в виде списка (нужен для работы с циклом for)

# new_d = {2:'перезаписали значение двойки', 'профессия':'программист'}
# print(d1)
# d1.update(new_d) # добавить пары ключ:значение из одного словаря в другой, если ключи уже существуют их значения будут перезаписаны
# print(d1)

# a = d1.copy() # создаёт поверхностную копию словаря в новой переменной
# a = dict(d1) # поверхностная копия конструктором
# print(id(a), id(d1))

# print(len(d1)) # узнать количество пар в словаре
# print(2 in d1) # узнать есть ли такой ключ в словаре
# узнать есть ли несколько ключей в словаре
# print({"is_current", "is_previous"} <= dict(is_current=True, is_previous=False).keys())

# print(sorted(d1, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)

################################### ПРИМЕРЫ для Словаря ###################################

# class_room = {'Ivan':17, 'Nikolay':18, 'Klara':16}
# пробегаемся циклом по словарю без методов, получаем только ключи
# for key in class_room:
#     print(key)

# пробегаемся циклом по словарю методом keys(), получаем только ключи
# for key in class_room.keys():
#     print(key)

# пробегаемся циклом по словарю методом values() получаем только значения
# for value in class_room.values():
#     print(value)

# пробегаемся циклом по словарю методом items() получаем ключи и значения
# for key, value in class_room.items():
#     print(key, value)

# проверка есть ли определенный ключ в словаре
# if 'Klara' in class_room:
#     print('Данный ключ уже используеться!')
# else:
#     print('Вы можете использовать данный ключ для создания пары.')


# person = {}
# s = 'IVANOV IVAN Samara SGU 5 4 5 5 4 3 5'
# s = s.split()
# person['lastName'] = s[0]
# person['firstName'] = s[1]
# person['city'] = s[2]
# person['university'] = s[3]
# person['marks'] = []
# for i in s[4:]:
#     person['marks'].append(int(i))
# print(person) # {'lastName': 'IVANOV', 'firstName': 'IVAN', 'city': 'Samara', 'university': 'SGU', 'marks': [5, 4, 5, 5, 4, 3, 5]}


# users = {
#     'Alex7': {'password':9856214, 'id':1957},
#     'Jimmy': {'password':1236487, 'id':9654},
#     'Bob33': {'password':9546752, 'id':6453}
# }
# # получить значение конкретного ключа в словаре можно с помощью квадратных скобок и имени ключа:
# print(users['Jimmy']['password'])
# print(users['Bob33']['id'])
# print(users['Alex7'])
# # либо же сразу всех элементов с помощью цикла
# for user_name, user_info in users.items():
#     password = user_info['password']
#     user_id = user_info['id']
#     print(f'Имя пользователя: {user_name} Пароль пользователя: {password} Айди пользователя: {user_id}')


# подсчёт уникальных символов в строке
# s = 'ssss dd  aaa'
# d = {}
# for i in s:
#     if i in d:
#         d[i] += 1
#     else:
#         d[i] = 1
# print(d)


# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# new = {}
# for i in price:
#     # копируем скидку 15% в новый словарь
#     new[i] = round(price[i] * 0.85, 2)
# print(price,"\n")
# print(new)


# price = {'meat':2, 'bread':1, 'potato':0.5, 'water':0.2}
# new = {}
# for key, value in price.items():
#     new[value] = key # инверсия пары ключ значение
# print(price,"\n")
# print(new) # теперь ключём является стоимость товара а значением название


# price = {'meat':3, 'bread':1, 'potato':0.5, 'water':0.2}
# def buy():
#     pay = 0
#     print("\nЧто будете покупать?\n\nВыберите товар из списка ниже:\n\nmeat 3$, bread 1$, potato 0.5$, water 0.2$\n")
#     print("Как определитесь с выбором напишите end\n")
#     while True:
#         enter = input()
#         if enter == "end":
#             print("С вас: " + str(pay) + "$")
#             break
#         if enter in price:
#             pay += price[enter] # получаем значение из словаря price по ключу который введёт пользователь
#         else:
#             print('\nВыберите товар из списка ниже:\n\nmeat 3$, bread 1$, potato 0.5$, water 0.2$\n')
#     return str(pay) + "$"
# buy()

################################### Блок Словаря закончен ###################################

# flag = True
# x = int(input("Введите число: "))
# for i in range(1):
#     # если строка длинная то с помощью скобок её можно перенести
#     flag = ( flag and
#     x % 10 == 0 )
# print(flag)

# flag = False
# x = int(input("Введите число: "))
# for i in range(1):
#     flag = ( x % 10 == 0 ) or flag
# print(flag)

# Вложенные и последовательные if
# две записи снизу идентичны
# x = 6
# if x % 2 == 0:
#     if x % 3 == 0:
#         print('делиться на 6')

# if x % 2 == 0 and x % 3 == 0:
#     print('делиться на 6')

# каскадные конструкции
#  A    B    C    D
# --->|--->|--->|--->
#     0    5   10
# x = int(input("Введите число: "))
# if x < 0:
#     print("A")
# elif x < 5: # x >= 0
#     print("B")
# elif x < 10: # x >= 5
#     print("C")
# else: # x >= 10
#     print("D")

#     ^ y
#  2  |  1
# ----|---- > x
#  3  |  4
# y, x = 0, 0
# if y > 0:
#     if x > 0:
#         print(1)
#     else:
#         print(2)
# else:
#     if x < 0:
#         print(3)
#     else:
#         print(4)

####################
# Работа с файлами #
####################

# Контекстный менеджер with автоматически закрывает файл после работы с ним
# with open('C:\\pyTraining\\TestFolder\\Новый текстовый документ 4.txt', 'r') as file:
#     text = file.read()
#     print(text)

# записываем все пути из 'C:\\pyTraining\\TestFolder' в текстовый документ
# import os
# list_path = []
# for adress, folder, file, in os.walk('C:\\pyTraining\\TestFolder'):
#     for i in file:
#         full_path = os.path.join(adress, i)
#         list_path.append(full_path)
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt', 'w')
# for i in list_path:
#     file.write(i + '\n')
# file.close()

# находим определенный файл
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt')
# for i in file:
#     if 'testfile.exe' in i:
#         print(i)

# text = file.read() # прочитать весь файл целиком
# text = file.readline() # прочитать файл построчно
# text = file.readlines() # прочитать файл построчно и передать данные в переменную в виде списка
# text = file.write('строка текста') # записать в файл строку текста
# print(text)
# file.close() # закрыть файл

# 'r' Открыть для чтения (по умолчанию если не указывать параметр)
# 'w' Открыть для записи, содержимое файла удаляется, если файла нет, создаётся новый
# 'x' Открытие на запись, если файла не существует, иначе исключение.
# 'a' Открыть для дозаписи в конец файла, если файла нет, создаётся новый
# 't' Открыть в текстовом режиме (по умолчанию если не указывать параметр)
# 'b' Открыть в бинарном режиме (двоичном) 'rb', 'wb', 'ab'
# '+' Открыть для чтения и записи 'r+', 'w+', 'a+'

# запись текста в файл
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt', 'w')
# print(file)
# # file.write('текста строка')
# file.close()

# чтение текста из файла
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 1.txt')
# text = file.read()
# # text = file.read(5) # если указать число в функции read() можно прочитать определенное количество символов
# # text = file.seek(0) # указав число в функции seek() мы переместимся на чтение с указанного номера символа
# print(text)
# file.close()


# взаимодействие с бинарными файлами
# file = open('C:\\pyTraining\\TestFolder\\testfile.exe', 'rb')
# copy_file = open('C:\\pyTraining\\TestFolder\\Копия testfile.exe', 'wb')

# while True:
#     #                 1024 байт
#     value = file.read(1024*1024) # позволяет устанавливать сколько в ОЗУ во время копирования будет занимать место операция
#     print(value.__sizeof__()) # метод __sizeof__() позволяет узнать какой объем в ОЗУ занимает объект
#     if value.__sizeof__() == 33: # 33 не константа, может быть и другое число
#         break
#     copy_file.write(value)
# file.close()
# copy_file.close()


# # запись файла с определенной кодировкой
# file = open('C:\\pyTraining\TestFolder\Новый текстовый документ 2.txt', 'w', encoding='utf-8')
# file.write('string текста')
# file.close()
# # если файл записан с необычной кодировской можно указать её для корректного чтения
# file2 = open('C:\\pyTraining\TestFolder\Новый текстовый документ 2.txt', encoding='utf-8')
# print(file2.read())

#######################################################################################################
# Множество (set) неупорядоченная коллекция уникальных элементов (отсутствуют повторяющиеся значения) #
# может состоять только из неизменяемых типов данных: число, строка, кортеж                           #
#######################################################################################################

# создать можно с помощью фигурных скобок
# a = {} # пустые фигурные скобки работают как словарь (dict), если перечислить данные через запятую получится множество
# так же создать множество можно с помощью функции set()
# y = set()
# print({"a", "a", "f", 1, 1, 1, 2, 3, 5, 25, (2, 5), (2, 5)}) # множество автоматически убирает повторяющиеся значения
# преобразуем список с повторяющимися значениями в множество затем обратно в список, тем самым убирая повторяющиеся значения
# print(list(set([1, 1, 2, 2, 3, 3, 4, 4, 5, 5])))

# x_tuple = (1, 2, 3, 4, 5, 6, 7)
# x_list = [1, 2, 3, 4, 5, 6, 7]
# x_dict = {'1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7}
# x_set = {1, 2, 3, 4, 5, 6, 7} # множества работают гораздо быстрее чем остальные типы списков
# # размер списка в памяти
# print(x_tuple.__sizeof__()) # 80
# print(x_list.__sizeof__()) # 96
# print(x_dict.__sizeof__()) # 344
# print(x_set.__sizeof__(), '\n') # 712
# from sys import getsizeof
# print(getsizeof(x_tuple)) # 80
# print(getsizeof(x_list)) # 96
# print(getsizeof(x_dict)) # 344
# print(getsizeof(x_set)) # 712

# Сравнение в скорости работы списка со множеством
# import time
# def f(*args):
#     list_new = []
#     for i in args:
#         for y in i:
#             if y not in list_new:
#                 list_new.append(y)
#     return list_new

# z = list(range(10000))
# x = list(range(5000, 15000))
# c = list(range(10000, 20000))

# start = time.time()
# f(z, x, c)
# stop = time.time() - start
# print('Время работы со списком:', stop)

# start2 = time.time()
# r = set(z)
# t = r.union(set(x), set(c))
# stop2 = time.time() - start2
# print('Время работы с множеством:', stop2)

# так же существует такой тип данных как frozenset, это множество элементы которого нельзя изменять
# print(frozenset([1, 1, "a"]), type(  frozenset([1, 1, "a"])  ))

# с множеством можно работать только при помощи методов

##########################################
# Методы для работы со множествами (set) #
##########################################

# z = {1, 2, 3, 4, 5}
# x = {3, 4, 5, 6, 7}

# при добавлении или объединении значения которые повторяются не будут дублироваться
# z.add(6) # добавить один элемент в множество
# z.discard(4) # удалить один элемент из множества (ничего не делает если такого элемента нет)
# z.remove(6) # удалить один элемент из множества (дропает исключение KeyError если такого элемента нет)
# z.pop() # удалить первый элемент из множества,
# но т.к. в множестве элементы не имеют постоянной позиции, по сути удаляет случайный элемент
# z.clear() # удалить все элементы из множества
# y = z.copy() # поверхностная копия методом
# y = set(z) # поверхностная копия конструктором

# print(id(z), id(y))

# z.update([7, 8]) # добавить значения из итерабильного объекта в множество
# z.update((9, 10))
# z.update({11, 12})
# z.update('ABCD')

# четыре метода реализующих операторы могут принимать в качестве аргументов не только множества,
# но и любые коллекции которые содержат исключительно неизменяемые объекты
# lst1 = [17, 18]; lst2 = [19, 20]
# z.update(x, lst1, lst2)

# z.update(x) # перезаписать объединённые множества в z # аналог z |= x
# y = z.union(x) # объединить множества # аналог y = z | x
# так же для объединения можно использовать синтаксис: y = {*z, *x}

# y = z.intersection(x) # получить повторяющиеся элементы в двух множествах # аналог y = z & x
# z.intersection_update(x) # перезаписать в z пересечение значений # аналог z &= x

# y = z.difference(x) # получить не повторяющиеся элементы из первого множества # аналог y = z - x
# z.difference_update(x) # перезаписать в z не повторяющиеся элементы из первого множества # аналог z -= x

# y = z.symmetric_difference(x) # получить не повторяющиеся элементы из первого и второго множества одновременно # аналог y = z ^ x
# z.symmetric_difference_update(x) # перезаписать в z не повторяющиеся элементы из первого и второго множества одновременно # аналог z ^= x

# print(len(z)) # узнать количество элементов в множестве
# print(4 in z) # узнать есть ли конкретное значение в множестве
# print(z == x) # множества равны

# z = {1, 2, 3}; x = {1, 2}
# print(z > x) # z является надмножеством x
# print(z < x) # z является подмножеством x

# z.issubset(x) # или  z <= x  все элементы z принадлежат x.
# z.issuperset(x) # или  z >= x  аналогично issubset.
# z.isdisjoint(x) # истина, если z и x не имеют общих элементов (не пересекаются).

# print('z:', z)
# print('x:', x)
# print('y:', y)

# print(sorted(z, reverse=True)) # возвращает новый отсортированный список в переменную (родительский не трогает)

###############################################################################################
# Строка (str) упорядоченная последовательность символов (присутствуют повторяющиеся символы) #
###############################################################################################

# поставив обратный слэш перед кавычками можно экранировать их
# тем самым вывести этот символ просто в качестве визуального элемента
# print("Я \"Арсений\" всем привет!")
# print('Я "Арсений" всем привет!')

# перенос строки на следующую строку (просто для оптимизации места на экране) (так же работает и для обычного кода)
# s = "qwerty\
# uiopa\
# sdfgh\
# jklzx\
# cvbnm"
# print(s)

# аналог переноса строки с помощью тройных кавчек (""", ''', ```)
# s = """qwerty
# uiopa
# sdfgh
# jklzx
# cvbnm"""
# print(s)

# строки могут сами конкатенироватся даже без '+'
# a = 'первый ' 'второй '   'третий'
# print(a)
# b = ('четвёртый '
#      'пятый '
#      'шестой')
# print(b)

# \n позволяет переносить строку на следующую по настоящему

# экранирование переноса строки изза \n с помощью второго слэша
# x = "https:\www.youtube.com\nexttab"
# x = "https:\www.youtube.com\\nexttab"

# специальный символ r перед строкой запрещает применять управляющие символы в данной строке
# x = r"https:\www.youtube.com\nexttab"
# для работы с путями в виндовс можно использовать r либо везде ставить двойной слэш
# x = 'C:\\Users\\PyHS\\Desktop'
# print(x)

# символы r, f можно совмещать в одной строке
# print(rf'adada{123}bcbc')

# print('\f \v') # гендерные символы

# print('123\r456') # \r возврат в начало текущей строки
# print('123\b\b456') # \b возврат на один символ назад в текущей строке

# экранирование слэш что бы он не экранировал кавычку
# ('D:\')
# ('D:\\')

# сложение строк(конкатенация)
# a = "Привет " + "Мир!"
# print(a)

# Сравнение строк
# print('abc' > 'r') # Получим False т.к. сравнение начинается с 1 символа а 'r' имеет больший порядковый номер чем 'a'
# print(ord('a'), ord('r'), ord('2'), ord('7')) # функция ord позволяет узнать номер символа в таблице ASCII
# print(chr(ord('a')), chr(ord('r'))) # функция chr наоборот переводит номер символа в сам символ
# print('abc' < 'abcd') # если символы в строках одинаковые но одна строка длиннее другой то True будет на стороне более длинной строки

# s = "stroka texta"
# print(s[5]) # получаем конкретный символ по индексу
# print(s[2:6]) # срез строки со 2 по 6 символ
# print(s[3:]) # срез с левой стороны
# print(s[:9]) # срез с правой стороны
# print(s[::2]) # срез символов через символ
# print(s[::-1]) # инвертируем строку с помощью среза
# print(s[-2:]) # срез с конца без необходимости указывать длину строки "abcdef"[-2:] -> "ef"
# print(s[:2]) # срез с конца без необходимости указывать длину строки "abcdef"[:2] -> "ab"
# print(s[:-2]) # срез с конца без необходимости указывать длину строки "abcdef"[:-2] -> "abcd"
# print(s[:len(s)-2]) # срез с конца с указанием длины строки           "abcdef"[:len(s)-2] -> "abcd"

# срез можно создавать и с помощью класса и передавать его в квадратные скобки
# myslice = slice(None, None, -1) # инвертируем строку с помощью класса среза
# print(s[myslice])

# print([0, 1, 2, 3, 4, 5][:-3])
# print([0, 1, 2, 3, 4, 5][slice(None, -3, None)]) # срез с конца без необходимости указывать длину строки
# print([0, 1, 2, 3, 4, 5][::2])
# print([0, 1, 2, 3, 4, 5][slice(None, None, 2)]) # срез символов через символ

# с помощью срезов можно изменять/удалять определённые участки последовательности
# l = list(range(10))
# print(l)
# l[2:5] = [20, 30]
# print(l)
# del l[5:7]
# print(l)
# l[3:2] = [11, 22]
# print(l)
# l[2:5] = [100]
# print(l)

# с помощью срезов можно изменять список присваиванием на месте
# a = [1, 2, 3, 4, 5, 6]
# b = ['A', 'B', 'C']
# a[1::2] = b
# print(a)
# print(b)

# a = [1, 2, 3, 4, 5, 6]
# b = ['A', 'B', 'C']
# a[::2] = b
# print(a)
# print(b)

# a = ['a', 'b', 'c', 'd', 'e', 'f']
# a[::2] = map(str.upper, a[::2])
# print(a)


# инвертируем строку обращаясь по индексу
# text = 'Кошка'
# print(text[4]+text[3]+text[2]+text[1]+text[0])

# инвертируем строку любой длинны с помощью цикла
# cat = 'Кошка'
# tac_table = []
# count = 0

# for letter in range(0, len(cat)):
#     count -= 1
#     tac_table.append(cat[count])

# inverseCat = ''.join(tac_table)
# print(inverseCat)

# инвертируем строку с помощью метода списков reverse()
# cat = 'Кошка'
# # превращаем строку в список с помощью генератора списка
# cat_table = [x for x in cat]
# cat_table.reverse() # применяем метод
# # превращаем инвертированный список обратно в строку
# inverseCat = ''.join(cat_table)
# print(inverseCat)

# cat = 'Кошка'

# print(''.join(list(reversed(cat))).capitalize())

# print(''.join(c for c in reversed(cat)).capitalize())

# print(''.join(cat[i] for i in range(len(cat)-1, -1, -1)).capitalize())

# print(cat[::-1].capitalize())

# cat = list(cat)
# cat.reverse()
# print(''.join(cat).capitalize())

# возвращает True/False в зависимости от того есть ли такой текст в таком порядке символов в проверяемой строке или нет
# print('stra' in s)

#######################################
# Методы для работы со строками (str) #
#######################################

# s = 'Привет мир! Как дела народ?'
# уточнение для методов (find, rindex, count) индексация всегда идёт слева на право
# если указанного символа нет в тексте (find вернёт -1)(index вернёт ValueError)(count вернёт 0)
# (find, index, count) могут принимать доп арг. start, stop с какого и до какого индекса
# print(s.find('д')) # возвращает индекс первого попавшегося искомого символа либо строки из нескольких символов # метод rfind() ищет первый попавшийся символ справа на лево
# print(s.rindex('д')) # идентично с find просто может сыпать разные эрроры # rindex()
# print(s.count('д')) # узнать количество определенных символов
# print(len(s)) # узнать количество всех символов в строке
# print(s.upper()) # переводит все символы в верхний регистр
# print(s.lower()) # переводит все символы в нижний регистр
# print("Grüßen".casefold()) # агрессивно приводит строку к нижнему регистру, заменяя неприводимые символы на их аналоги (например немецкую букву ß на ss)
# print('a'.isupper(), 'A'.islower()) # проверит принадлежит ли символ к проверяемому регистру, вернёт булевое значение
# print('a'.swapcase(), 'A'.swapcase()) # меняет регистр на противоположный (переводит символы верхнего регистра в нижний регистр, а символы нижнего регистра в верхний регистр)
# print(s.capitalize()) # переводит первую букву в строке в верхний регистр а все остальные в нижний регистр
# print(s.title()) # переводит первую букву во всех словах в строке в верхний регистр
# print(s.istitle()) # если в строке большая буква только первая возвращает True иначе False
# print(s.strip()) # по дефолту удаляет неограниченное количество пробелов и преносов строк в начале и конце строки
# если указать символ он сделает тоже самое только с ним. Ещё методы которые убирают только с левой либо с правой стороны (lstrip, rstrip)
# print(s.isalpha()) # если символы являются только буквами возвращает True, иначе False
# print('17'.isdigit()) # если символы являются только числами возвращает True, иначе False
# print('17'.isdecimal()) # проверяет строку, если строка является исключительно десятичной
# print('17'.isnumeric()) # проверяет строку, если строка является исключительно числовой
# print(s.isalnum()) # если строка состоит из букв либо цифр или из букв вместе цифрами возвращает True иначе False
# print(s.replace('е', ' ^_^', 1)) # заменяет выбранный символ на другой, может принимать 3 арг. сколько замен надо произвести
# print(s.split('а')) # разделяет строку на сектора по выбранному символу и возвращает их в виде списка (по умолчанию по пробелам)
# print('111'.rjust(7, '$')) # вставляет символ заполнитель слева от строки # ljust аналогично только справа (по умолчанию заполн. пробел)
# print('abcd'.startswith('ab'), 'abcd'.startswith('ba')) # сравнивает указанный префикс с началом строки возвращает True если префикс совпадает
# print('abcd'.endswith('cd'), 'abcd'.endswith('dc')) # сравнивает указанный префикс с концом строки возвращает True если префикс совпадает
# print(''.isprintable(), '?'.isprintable()) # проверяет что все символы в строке доступны для корректной печати
# метод format позволяет подставлять значения в строку, аналог f-string
# print('текст {0} текст {1}\n'.format('a', 2), 'текст {name} текст {age}\n'.format(name='Arseniy', age=24), 'текст {name} текст\n'.format(**{'name': 'Guido'}))

# format позволяет обращаться к атрибутам переданного объекта при форматировании
# class Response:
#     status_code = 404
#     message = 'Not Found'
# response = Response()
# error_msg = "HTTP error {resp.status_code} - {resp.message}"
# error_msg = error_msg.format(resp=response)
# print(error_msg)

# метод format_map отличается от обычного format тем что не создаёт новый словарь
# и не выбрасывает исключение KeyError за счёт дандер метода __missing__ в случае отсутствия ключа
# class Default(dict):
#     def __missing__(self, key):
#         return key
# print('{name} имя есть а страну не передали {country}'.format_map(Default(name='Guido')))

# s = 'café'
# print('строка:', s, len(s))
# s = s.encode('utf8') # метод позволяет преобразовывать строку в байт-строку
# # количество символов != количеству байт, один символ может занимать более 1 байта.
# print('строка после кодирования:', s, len(s))
# s = s.decode('utf8') # метод позволяет преобразовывать байт-строку в строку
# print('строка после декодирования:', s, len(s))

# метод строк translate позволяет заменить некоторые знаки или удалить их
# в методе str.maketrans 1 и 2 арг. отвечает за то какой знак на какой заменять, 3 арг что удалить из строки
# с помощью метода punctuation из модуля string получаем строку со знаками пунктуации
# from string import punctuation
# print(s.translate(str.maketrans('', '', punctuation)))
# print(punctuation)

# print(''.join(list(reversed('98765')))) # пример

# print(repr('строка вместе с одинарными кавычками\n\n')) # возвращает строку вместе с кавычками и управляющими знаками
# print('строка вместе с одинарными кавычками\n\n'.__repr__())

# метод строк isidentifier и функция iskeyword позволяют проверить,
# можно ли использовать данное имя для объявления, переменной, функции, класса
# то есть не зарезервировано ли оно самим языком.
# from keyword import iskeyword
# s = 'class'
# print(s.isidentifier() and iskeyword(s))
